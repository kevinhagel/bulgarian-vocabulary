---
phase: 06-flashcards-basic-study
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/main/resources/db/migration/V5__add_srs_study_tables.sql
  - backend/src/main/java/com/vocab/bulgarian/study/domain/SrsState.java
  - backend/src/main/java/com/vocab/bulgarian/study/domain/StudySession.java
  - backend/src/main/java/com/vocab/bulgarian/study/domain/SessionCard.java
  - backend/src/main/java/com/vocab/bulgarian/study/domain/StudyReview.java
  - backend/src/main/java/com/vocab/bulgarian/study/domain/enums/SessionStatus.java
  - backend/src/main/java/com/vocab/bulgarian/study/domain/enums/ReviewRating.java
  - backend/src/main/java/com/vocab/bulgarian/study/repository/SrsStateRepository.java
  - backend/src/main/java/com/vocab/bulgarian/study/repository/StudySessionRepository.java
  - backend/src/main/java/com/vocab/bulgarian/study/repository/SessionCardRepository.java
  - backend/src/main/java/com/vocab/bulgarian/study/repository/StudyReviewRepository.java
  - backend/src/main/java/com/vocab/bulgarian/study/service/SrsAlgorithmService.java
  - backend/src/main/java/com/vocab/bulgarian/study/service/StudySessionService.java
  - backend/src/main/java/com/vocab/bulgarian/study/dto/StartSessionResponseDTO.java
  - backend/src/main/java/com/vocab/bulgarian/study/dto/StudyCardDTO.java
  - backend/src/main/java/com/vocab/bulgarian/study/dto/RateCardRequestDTO.java
  - backend/src/main/java/com/vocab/bulgarian/study/dto/SessionSummaryDTO.java
  - backend/src/main/java/com/vocab/bulgarian/study/dto/DueCountDTO.java
  - backend/src/main/java/com/vocab/bulgarian/study/controller/StudyController.java
autonomous: true

must_haves:
  truths:
    - "V5 migration creates srs_state, study_sessions, session_cards, study_reviews tables"
    - "POST /api/study/sessions starts a session and returns StartSessionResponseDTO with sessionId and first card"
    - "GET /api/study/sessions/{id}/next returns StudyCardDTO or 204 when session complete"
    - "POST /api/study/sessions/{id}/rate accepts RateCardRequestDTO, updates SrsState, returns next card"
    - "POST /api/study/sessions/{id}/end marks session COMPLETED, returns SessionSummaryDTO"
    - "GET /api/study/due-count returns DueCountDTO with dueToday and newCards"
    - "SM-2 CORRECT: interval 0→1→6→prev*EF; INCORRECT: reset to 1, EF max(1.30, EF-0.20)"
    - "mvn compile -q passes"
  artifacts:
    - path: "backend/src/main/resources/db/migration/V5__add_srs_study_tables.sql"
      provides: "SRS and study schema"
      contains: "srs_state"
    - path: "backend/src/main/java/com/vocab/bulgarian/study/service/SrsAlgorithmService.java"
      provides: "SM-2 spaced repetition algorithm"
      contains: "calculateNextReview"
    - path: "backend/src/main/java/com/vocab/bulgarian/study/service/StudySessionService.java"
      provides: "Session lifecycle: start, next card, rate, end"
      contains: "startSession"
    - path: "backend/src/main/java/com/vocab/bulgarian/study/controller/StudyController.java"
      provides: "REST API for study sessions"
      contains: "/api/study/sessions"
---

<objective>
Build the complete SRS backend: database schema, JPA entities, SM-2 algorithm, session service, and REST API. This is the foundation all other Phase 6 plans depend on.

Purpose: Enable the flashcard study loop — start session, get next card, rate it, advance SRS schedule.
Output: 5 REST endpoints working. SM-2 updates srs_state correctly after each rating.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Flyway V5 migration — SRS and study tables</name>
  <files>
    backend/src/main/resources/db/migration/V5__add_srs_study_tables.sql
  </files>
  <action>
    Create `backend/src/main/resources/db/migration/V5__add_srs_study_tables.sql`:

    ```sql
    -- SRS state: one row per studied USER_ENTERED lemma
    CREATE TABLE srs_state (
        id                BIGSERIAL PRIMARY KEY,
        lemma_id          BIGINT NOT NULL UNIQUE REFERENCES lemmas(id) ON DELETE CASCADE,
        ease_factor       DECIMAL(4,2) NOT NULL DEFAULT 2.50,
        interval_days     INT NOT NULL DEFAULT 0,
        repetition_count  INT NOT NULL DEFAULT 0,
        next_review_date  DATE NOT NULL DEFAULT CURRENT_DATE,
        last_reviewed_at  TIMESTAMP WITH TIME ZONE,
        created_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        updated_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    );

    CREATE INDEX idx_srs_state_lemma_id ON srs_state(lemma_id);
    CREATE INDEX idx_srs_state_next_review ON srs_state(next_review_date);

    -- Study sessions
    CREATE TABLE study_sessions (
        id              BIGSERIAL PRIMARY KEY,
        status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
        card_count      INT NOT NULL DEFAULT 0,
        cards_reviewed  INT NOT NULL DEFAULT 0,
        correct_count   INT NOT NULL DEFAULT 0,
        started_at      TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        ended_at        TIMESTAMP WITH TIME ZONE,
        CONSTRAINT chk_session_status CHECK (status IN ('ACTIVE','COMPLETED','ABANDONED'))
    );

    -- Session cards: ordered list of lemma IDs for this session
    CREATE TABLE session_cards (
        session_id  BIGINT NOT NULL REFERENCES study_sessions(id) ON DELETE CASCADE,
        lemma_id    BIGINT NOT NULL REFERENCES lemmas(id) ON DELETE CASCADE,
        position    INT NOT NULL,
        reviewed    BOOLEAN NOT NULL DEFAULT FALSE,
        PRIMARY KEY (session_id, lemma_id)
    );

    CREATE INDEX idx_session_cards_session_position ON session_cards(session_id, position);

    -- Study reviews: one row per card rating event
    CREATE TABLE study_reviews (
        id           BIGSERIAL PRIMARY KEY,
        session_id   BIGINT NOT NULL REFERENCES study_sessions(id) ON DELETE CASCADE,
        lemma_id     BIGINT NOT NULL REFERENCES lemmas(id) ON DELETE CASCADE,
        rating       VARCHAR(20) NOT NULL,
        reviewed_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        CONSTRAINT chk_review_rating CHECK (rating IN ('CORRECT','INCORRECT'))
    );

    CREATE INDEX idx_study_reviews_lemma_id ON study_reviews(lemma_id);
    CREATE INDEX idx_study_reviews_session_id ON study_reviews(session_id);
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && export POSTGRES_PASSWORD='BG_Vocab_2026_PostgreSQL!' && mvn flyway:migrate -q 2>&1 | tail -5
    # Should show "Successfully applied 1 migration"
    mvn flyway:info 2>&1 | grep V5
    # Shows V5 as Success
  </verify>
  <done>V5 migration applied. srs_state, study_sessions, session_cards, study_reviews tables exist.</done>
</task>

<task type="auto">
  <name>Task 2: JPA entities, enums, and repositories</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/study/domain/enums/SessionStatus.java
    backend/src/main/java/com/vocab/bulgarian/study/domain/enums/ReviewRating.java
    backend/src/main/java/com/vocab/bulgarian/study/domain/SrsState.java
    backend/src/main/java/com/vocab/bulgarian/study/domain/StudySession.java
    backend/src/main/java/com/vocab/bulgarian/study/domain/SessionCard.java
    backend/src/main/java/com/vocab/bulgarian/study/domain/StudyReview.java
    backend/src/main/java/com/vocab/bulgarian/study/repository/SrsStateRepository.java
    backend/src/main/java/com/vocab/bulgarian/study/repository/StudySessionRepository.java
    backend/src/main/java/com/vocab/bulgarian/study/repository/SessionCardRepository.java
    backend/src/main/java/com/vocab/bulgarian/study/repository/StudyReviewRepository.java
  </files>
  <action>
    **Enums:**

    `SessionStatus.java`:
    ```java
    package com.vocab.bulgarian.study.domain.enums;
    public enum SessionStatus { ACTIVE, COMPLETED, ABANDONED }
    ```

    `ReviewRating.java`:
    ```java
    package com.vocab.bulgarian.study.domain.enums;
    public enum ReviewRating { CORRECT, INCORRECT }
    ```

    **SrsState entity:**
    ```java
    package com.vocab.bulgarian.study.domain;

    import com.vocab.bulgarian.domain.Lemma;
    import jakarta.persistence.*;
    import java.math.BigDecimal;
    import java.time.LocalDate;
    import java.time.ZonedDateTime;

    @Entity
    @Table(name = "srs_state")
    public class SrsState {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @OneToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "lemma_id", nullable = false, unique = true)
        private Lemma lemma;

        @Column(name = "ease_factor", nullable = false, precision = 4, scale = 2)
        private BigDecimal easeFactor = new BigDecimal("2.50");

        @Column(name = "interval_days", nullable = false)
        private int intervalDays = 0;

        @Column(name = "repetition_count", nullable = false)
        private int repetitionCount = 0;

        @Column(name = "next_review_date", nullable = false)
        private LocalDate nextReviewDate = LocalDate.now();

        @Column(name = "last_reviewed_at")
        private ZonedDateTime lastReviewedAt;

        @Column(name = "created_at", nullable = false, updatable = false)
        private ZonedDateTime createdAt = ZonedDateTime.now();

        @Column(name = "updated_at", nullable = false)
        private ZonedDateTime updatedAt = ZonedDateTime.now();

        @PreUpdate
        void onUpdate() { this.updatedAt = ZonedDateTime.now(); }

        // getters and setters
        public Long getId() { return id; }
        public Lemma getLemma() { return lemma; }
        public void setLemma(Lemma lemma) { this.lemma = lemma; }
        public BigDecimal getEaseFactor() { return easeFactor; }
        public void setEaseFactor(BigDecimal easeFactor) { this.easeFactor = easeFactor; }
        public int getIntervalDays() { return intervalDays; }
        public void setIntervalDays(int intervalDays) { this.intervalDays = intervalDays; }
        public int getRepetitionCount() { return repetitionCount; }
        public void setRepetitionCount(int repetitionCount) { this.repetitionCount = repetitionCount; }
        public LocalDate getNextReviewDate() { return nextReviewDate; }
        public void setNextReviewDate(LocalDate nextReviewDate) { this.nextReviewDate = nextReviewDate; }
        public ZonedDateTime getLastReviewedAt() { return lastReviewedAt; }
        public void setLastReviewedAt(ZonedDateTime lastReviewedAt) { this.lastReviewedAt = lastReviewedAt; }
        public ZonedDateTime getUpdatedAt() { return updatedAt; }
    }
    ```

    **StudySession entity:**
    ```java
    package com.vocab.bulgarian.study.domain;

    import com.vocab.bulgarian.study.domain.enums.SessionStatus;
    import jakarta.persistence.*;
    import java.time.ZonedDateTime;
    import java.util.ArrayList;
    import java.util.List;

    @Entity
    @Table(name = "study_sessions")
    public class StudySession {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @Enumerated(EnumType.STRING)
        @Column(nullable = false)
        private SessionStatus status = SessionStatus.ACTIVE;

        @Column(name = "card_count", nullable = false)
        private int cardCount = 0;

        @Column(name = "cards_reviewed", nullable = false)
        private int cardsReviewed = 0;

        @Column(name = "correct_count", nullable = false)
        private int correctCount = 0;

        @Column(name = "started_at", nullable = false, updatable = false)
        private ZonedDateTime startedAt = ZonedDateTime.now();

        @Column(name = "ended_at")
        private ZonedDateTime endedAt;

        @OneToMany(mappedBy = "session", cascade = CascadeType.ALL, orphanRemoval = true)
        @OrderBy("position ASC")
        private List<SessionCard> cards = new ArrayList<>();

        public Long getId() { return id; }
        public SessionStatus getStatus() { return status; }
        public void setStatus(SessionStatus status) { this.status = status; }
        public int getCardCount() { return cardCount; }
        public void setCardCount(int cardCount) { this.cardCount = cardCount; }
        public int getCardsReviewed() { return cardsReviewed; }
        public void setCardsReviewed(int cardsReviewed) { this.cardsReviewed = cardsReviewed; }
        public int getCorrectCount() { return correctCount; }
        public void setCorrectCount(int correctCount) { this.correctCount = correctCount; }
        public ZonedDateTime getStartedAt() { return startedAt; }
        public ZonedDateTime getEndedAt() { return endedAt; }
        public void setEndedAt(ZonedDateTime endedAt) { this.endedAt = endedAt; }
        public List<SessionCard> getCards() { return cards; }
    }
    ```

    **SessionCard entity:**
    ```java
    package com.vocab.bulgarian.study.domain;

    import com.vocab.bulgarian.domain.Lemma;
    import jakarta.persistence.*;

    @Entity
    @Table(name = "session_cards")
    public class SessionCard {
        @EmbeddedId
        private SessionCardId id = new SessionCardId();

        @ManyToOne(fetch = FetchType.LAZY)
        @MapsId("sessionId")
        @JoinColumn(name = "session_id")
        private StudySession session;

        @ManyToOne(fetch = FetchType.LAZY)
        @MapsId("lemmaId")
        @JoinColumn(name = "lemma_id")
        private Lemma lemma;

        @Column(nullable = false)
        private int position;

        @Column(nullable = false)
        private boolean reviewed = false;

        public SessionCardId getId() { return id; }
        public StudySession getSession() { return session; }
        public void setSession(StudySession session) { this.session = session; }
        public Lemma getLemma() { return lemma; }
        public void setLemma(Lemma lemma) { this.lemma = lemma; }
        public int getPosition() { return position; }
        public void setPosition(int position) { this.position = position; }
        public boolean isReviewed() { return reviewed; }
        public void setReviewed(boolean reviewed) { this.reviewed = reviewed; }
    }
    ```

    **SessionCardId embeddable:**
    ```java
    package com.vocab.bulgarian.study.domain;

    import jakarta.persistence.Embeddable;
    import java.io.Serializable;
    import java.util.Objects;

    @Embeddable
    public class SessionCardId implements Serializable {
        private Long sessionId;
        private Long lemmaId;

        public Long getSessionId() { return sessionId; }
        public void setSessionId(Long sessionId) { this.sessionId = sessionId; }
        public Long getLemmaId() { return lemmaId; }
        public void setLemmaId(Long lemmaId) { this.lemmaId = lemmaId; }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof SessionCardId that)) return false;
            return Objects.equals(sessionId, that.sessionId) && Objects.equals(lemmaId, that.lemmaId);
        }
        @Override
        public int hashCode() { return Objects.hash(sessionId, lemmaId); }
    }
    ```

    **StudyReview entity:**
    ```java
    package com.vocab.bulgarian.study.domain;

    import com.vocab.bulgarian.domain.Lemma;
    import com.vocab.bulgarian.study.domain.enums.ReviewRating;
    import jakarta.persistence.*;
    import java.time.ZonedDateTime;

    @Entity
    @Table(name = "study_reviews")
    public class StudyReview {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "session_id", nullable = false)
        private StudySession session;

        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "lemma_id", nullable = false)
        private Lemma lemma;

        @Enumerated(EnumType.STRING)
        @Column(nullable = false)
        private ReviewRating rating;

        @Column(name = "reviewed_at", nullable = false)
        private ZonedDateTime reviewedAt = ZonedDateTime.now();

        public Long getId() { return id; }
        public StudySession getSession() { return session; }
        public void setSession(StudySession session) { this.session = session; }
        public Lemma getLemma() { return lemma; }
        public void setLemma(Lemma lemma) { this.lemma = lemma; }
        public ReviewRating getRating() { return rating; }
        public void setRating(ReviewRating rating) { this.rating = rating; }
        public ZonedDateTime getReviewedAt() { return reviewedAt; }
    }
    ```

    **Repositories:**

    `SrsStateRepository.java`:
    ```java
    package com.vocab.bulgarian.study.repository;

    import com.vocab.bulgarian.study.domain.SrsState;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.query.Param;
    import java.time.LocalDate;
    import java.util.List;
    import java.util.Optional;

    public interface SrsStateRepository extends JpaRepository<SrsState, Long> {
        Optional<SrsState> findByLemmaId(Long lemmaId);

        @Query("SELECT s FROM SrsState s WHERE s.nextReviewDate <= :today")
        List<SrsState> findDueCards(@Param("today") LocalDate today);

        @Query("SELECT COUNT(s) FROM SrsState s WHERE s.nextReviewDate <= :today")
        long countDueCards(@Param("today") LocalDate today);

        @Query("""
            SELECT l.id FROM Lemma l
            WHERE l.source = 'USER_ENTERED'
            AND l.processingStatus = 'COMPLETED'
            AND l.id NOT IN (SELECT s.lemma.id FROM SrsState s)
            """)
        List<Long> findLemmaIdsWithoutSrsState();
    }
    ```

    `StudySessionRepository.java`:
    ```java
    package com.vocab.bulgarian.study.repository;

    import com.vocab.bulgarian.study.domain.StudySession;
    import com.vocab.bulgarian.study.domain.enums.SessionStatus;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Query;

    public interface StudySessionRepository extends JpaRepository<StudySession, Long> {
        long countByStatus(SessionStatus status);

        @Query("SELECT COALESCE(SUM(s.cardsReviewed), 0) FROM StudySession s")
        long sumTotalCardsReviewed();

        @Query("SELECT COALESCE(SUM(s.correctCount), 0) FROM StudySession s")
        long sumTotalCorrect();
    }
    ```

    `SessionCardRepository.java`:
    ```java
    package com.vocab.bulgarian.study.repository;

    import com.vocab.bulgarian.study.domain.SessionCard;
    import com.vocab.bulgarian.study.domain.SessionCardId;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.query.Param;
    import java.util.Optional;

    public interface SessionCardRepository extends JpaRepository<SessionCard, SessionCardId> {
        @Query("""
            SELECT sc FROM SessionCard sc
            JOIN FETCH sc.lemma
            WHERE sc.session.id = :sessionId
            AND sc.reviewed = false
            ORDER BY sc.position ASC
            """)
        Optional<SessionCard> findFirstUnreviewed(@Param("sessionId") Long sessionId);
    }
    ```

    `StudyReviewRepository.java`:
    ```java
    package com.vocab.bulgarian.study.repository;

    import com.vocab.bulgarian.study.domain.StudyReview;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.query.Param;

    public interface StudyReviewRepository extends JpaRepository<StudyReview, Long> {
        long countByLemmaId(Long lemmaId);

        @Query("SELECT COUNT(r) FROM StudyReview r WHERE r.lemma.id = :lemmaId AND r.rating = 'CORRECT'")
        long countCorrectByLemmaId(@Param("lemmaId") Long lemmaId);
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -10
  </verify>
  <done>All entities, embeddables, enums, and repositories compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: SrsAlgorithmService (SM-2) and StudySessionService</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/study/service/SrsAlgorithmService.java
    backend/src/main/java/com/vocab/bulgarian/study/service/StudySessionService.java
  </files>
  <action>
    **SrsAlgorithmService** — pure SM-2, no external dependencies:
    ```java
    package com.vocab.bulgarian.study.service;

    import com.vocab.bulgarian.study.domain.SrsState;
    import com.vocab.bulgarian.study.domain.enums.ReviewRating;
    import org.springframework.stereotype.Service;
    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.time.LocalDate;
    import java.time.ZonedDateTime;

    @Service
    public class SrsAlgorithmService {

        private static final BigDecimal MIN_EASE = new BigDecimal("1.30");
        private static final BigDecimal EASE_DECREASE = new BigDecimal("0.20");

        /**
         * Apply SM-2 algorithm to update SrsState based on rating.
         * CORRECT: interval 0→1→6→prev×EF (rounded), EF unchanged
         * INCORRECT: interval→1, repetitionCount→0, EF max(1.30, EF-0.20)
         */
        public SrsState applyRating(SrsState state, ReviewRating rating) {
            if (rating == ReviewRating.CORRECT) {
                int newInterval = switch (state.getRepetitionCount()) {
                    case 0 -> 1;
                    case 1 -> 6;
                    default -> (int) Math.round(state.getIntervalDays() * state.getEaseFactor().doubleValue());
                };
                state.setIntervalDays(Math.max(newInterval, 1));
                state.setRepetitionCount(state.getRepetitionCount() + 1);
            } else {
                state.setIntervalDays(1);
                state.setRepetitionCount(0);
                BigDecimal newEase = state.getEaseFactor().subtract(EASE_DECREASE);
                state.setEaseFactor(newEase.max(MIN_EASE).setScale(2, RoundingMode.HALF_UP));
            }
            state.setNextReviewDate(LocalDate.now().plusDays(state.getIntervalDays()));
            state.setLastReviewedAt(ZonedDateTime.now());
            return state;
        }
    }
    ```

    **StudySessionService**:
    ```java
    package com.vocab.bulgarian.study.service;

    import com.vocab.bulgarian.domain.Lemma;
    import com.vocab.bulgarian.repository.LemmaRepository;
    import com.vocab.bulgarian.study.domain.*;
    import com.vocab.bulgarian.study.domain.enums.ReviewRating;
    import com.vocab.bulgarian.study.domain.enums.SessionStatus;
    import com.vocab.bulgarian.study.dto.*;
    import com.vocab.bulgarian.study.repository.*;
    import jakarta.persistence.EntityNotFoundException;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import java.time.LocalDate;
    import java.util.*;

    @Service
    @Transactional
    public class StudySessionService {

        private static final Logger log = LoggerFactory.getLogger(StudySessionService.class);
        private static final int DEFAULT_MAX_CARDS = 20;
        private static final int MAX_NEW_CARDS_PER_SESSION = 10;

        private final StudySessionRepository sessionRepo;
        private final SessionCardRepository cardRepo;
        private final SrsStateRepository srsRepo;
        private final StudyReviewRepository reviewRepo;
        private final LemmaRepository lemmaRepo;
        private final SrsAlgorithmService algorithm;

        public StudySessionService(
            StudySessionRepository sessionRepo,
            SessionCardRepository cardRepo,
            SrsStateRepository srsRepo,
            StudyReviewRepository reviewRepo,
            LemmaRepository lemmaRepo,
            SrsAlgorithmService algorithm
        ) {
            this.sessionRepo = sessionRepo;
            this.cardRepo = cardRepo;
            this.srsRepo = srsRepo;
            this.reviewRepo = reviewRepo;
            this.lemmaRepo = lemmaRepo;
            this.algorithm = algorithm;
        }

        public StartSessionResponseDTO startSession(int maxCards) {
            // Collect due cards
            List<Long> dueLemmaIds = srsRepo.findDueCards(LocalDate.now())
                .stream().map(s -> s.getLemma().getId()).toList();

            // Collect new cards (no SrsState yet), capped
            List<Long> newLemmaIds = srsRepo.findLemmaIdsWithoutSrsState()
                .stream().limit(MAX_NEW_CARDS_PER_SESSION).toList();

            // Merge, deduplicate, shuffle, cap
            Set<Long> allIds = new LinkedHashSet<>(dueLemmaIds);
            allIds.addAll(newLemmaIds);
            List<Long> shuffled = new ArrayList<>(allIds);
            Collections.shuffle(shuffled);
            List<Long> sessionIds = shuffled.stream().limit(maxCards).toList();

            if (sessionIds.isEmpty()) {
                throw new IllegalStateException(
                    "No cards available for study. Add vocabulary or wait for scheduled review dates.");
            }

            // Ensure SrsState exists for all new cards
            for (Long lemmaId : newLemmaIds) {
                if (srsRepo.findByLemmaId(lemmaId).isEmpty()) {
                    Lemma lemma = lemmaRepo.getReferenceById(lemmaId);
                    SrsState state = new SrsState();
                    state.setLemma(lemma);
                    srsRepo.save(state);
                }
            }

            // Build session
            StudySession session = new StudySession();
            session.setCardCount(sessionIds.size());
            session = sessionRepo.save(session);

            for (int i = 0; i < sessionIds.size(); i++) {
                Lemma lemma = lemmaRepo.getReferenceById(sessionIds.get(i));
                SessionCard card = new SessionCard();
                card.setSession(session);
                card.setLemma(lemma);
                card.setPosition(i);
                cardRepo.save(card);
            }

            log.info("Study session {} started: {} due, {} new, {} total cards",
                session.getId(), dueLemmaIds.size(), newLemmaIds.size(), sessionIds.size());

            StudyCardDTO firstCard = getNextCard(session.getId());
            return new StartSessionResponseDTO(session.getId(), session.getCardCount(), firstCard);
        }

        @Transactional(readOnly = true)
        public StudyCardDTO getNextCard(Long sessionId) {
            return cardRepo.findFirstUnreviewed(sessionId)
                .map(sc -> toCardDTO(sc.getLemma(), sessionId))
                .orElse(null);
        }

        public StudyCardDTO rateCard(Long sessionId, Long lemmaId, ReviewRating rating) {
            StudySession session = sessionRepo.findById(sessionId)
                .orElseThrow(() -> new EntityNotFoundException("Session not found: " + sessionId));

            if (session.getStatus() != SessionStatus.ACTIVE) {
                throw new IllegalStateException("Session " + sessionId + " is not active");
            }

            // Mark card reviewed
            SessionCardId cardId = new SessionCardId();
            cardId.setSessionId(sessionId);
            cardId.setLemmaId(lemmaId);
            SessionCard card = cardRepo.findById(cardId)
                .orElseThrow(() -> new EntityNotFoundException("Card not found in session"));
            card.setReviewed(true);
            cardRepo.save(card);

            // Update SRS state
            SrsState state = srsRepo.findByLemmaId(lemmaId)
                .orElseThrow(() -> new EntityNotFoundException("SRS state not found for lemma: " + lemmaId));
            algorithm.applyRating(state, rating);
            srsRepo.save(state);

            // Record review event
            Lemma lemma = lemmaRepo.getReferenceById(lemmaId);
            StudyReview review = new StudyReview();
            review.setSession(session);
            review.setLemma(lemma);
            review.setRating(rating);
            reviewRepo.save(review);

            // Update session counters
            session.setCardsReviewed(session.getCardsReviewed() + 1);
            if (rating == ReviewRating.CORRECT) {
                session.setCorrectCount(session.getCorrectCount() + 1);
            }
            sessionRepo.save(session);

            log.info("Session {} card {} rated {} — interval now {}d",
                sessionId, lemmaId, rating, state.getIntervalDays());

            // Auto-complete if all reviewed
            boolean allDone = cardRepo.findFirstUnreviewed(sessionId).isEmpty();
            if (allDone) {
                session.setStatus(SessionStatus.COMPLETED);
                sessionRepo.save(session);
                log.info("Session {} auto-completed", sessionId);
            }

            return getNextCard(sessionId);
        }

        public SessionSummaryDTO endSession(Long sessionId) {
            StudySession session = sessionRepo.findById(sessionId)
                .orElseThrow(() -> new EntityNotFoundException("Session not found: " + sessionId));

            if (session.getStatus() == SessionStatus.ACTIVE) {
                session.setStatus(SessionStatus.ABANDONED);
                session.setEndedAt(java.time.ZonedDateTime.now());
                sessionRepo.save(session);
            }

            int retentionRate = session.getCardsReviewed() > 0
                ? (int) Math.round((double) session.getCorrectCount() / session.getCardsReviewed() * 100)
                : 0;

            return new SessionSummaryDTO(
                session.getId(),
                session.getStatus().name(),
                session.getCardCount(),
                session.getCardsReviewed(),
                session.getCorrectCount(),
                retentionRate
            );
        }

        @Transactional(readOnly = true)
        public DueCountDTO getDueCount() {
            long dueToday = srsRepo.countDueCards(LocalDate.now());
            long newCards = srsRepo.findLemmaIdsWithoutSrsState().size();
            return new DueCountDTO(dueToday, newCards);
        }

        private StudyCardDTO toCardDTO(Lemma lemma, Long sessionId) {
            long remaining = cardRepo.findFirstUnreviewed(sessionId).isPresent()
                ? sessionRepo.findById(sessionId)
                    .map(s -> (long)(s.getCardCount() - s.getCardsReviewed()))
                    .orElse(0L)
                : 0L;
            return new StudyCardDTO(lemma.getId(), lemma.getText(), lemma.getTranslation(), remaining);
        }
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -5
  </verify>
  <done>SrsAlgorithmService implements SM-2. StudySessionService handles full session lifecycle. Compile passes.</done>
</task>

<task type="auto">
  <name>Task 4: DTOs and StudyController REST API</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/study/dto/StartSessionResponseDTO.java
    backend/src/main/java/com/vocab/bulgarian/study/dto/StudyCardDTO.java
    backend/src/main/java/com/vocab/bulgarian/study/dto/RateCardRequestDTO.java
    backend/src/main/java/com/vocab/bulgarian/study/dto/SessionSummaryDTO.java
    backend/src/main/java/com/vocab/bulgarian/study/dto/DueCountDTO.java
    backend/src/main/java/com/vocab/bulgarian/study/controller/StudyController.java
  </files>
  <action>
    **DTOs (all records):**

    ```java
    // StartSessionResponseDTO.java
    package com.vocab.bulgarian.study.dto;
    public record StartSessionResponseDTO(Long sessionId, int cardCount, StudyCardDTO firstCard) {}

    // StudyCardDTO.java
    package com.vocab.bulgarian.study.dto;
    public record StudyCardDTO(Long lemmaId, String lemmaText, String translation, long cardsRemaining) {}

    // RateCardRequestDTO.java
    package com.vocab.bulgarian.study.dto;
    public record RateCardRequestDTO(Long lemmaId, String rating) {}

    // SessionSummaryDTO.java
    package com.vocab.bulgarian.study.dto;
    public record SessionSummaryDTO(Long sessionId, String status, int cardCount, int cardsReviewed, int correctCount, int retentionRate) {}

    // DueCountDTO.java
    package com.vocab.bulgarian.study.dto;
    public record DueCountDTO(long dueToday, long newCards) {}
    ```

    **StudyController:**
    ```java
    package com.vocab.bulgarian.study.controller;

    import com.vocab.bulgarian.study.domain.enums.ReviewRating;
    import com.vocab.bulgarian.study.dto.*;
    import com.vocab.bulgarian.study.service.StudySessionService;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;

    @RestController
    @RequestMapping("/api/study")
    public class StudyController {

        private final StudySessionService service;

        public StudyController(StudySessionService service) {
            this.service = service;
        }

        @PostMapping("/sessions")
        public ResponseEntity<StartSessionResponseDTO> startSession(
            @RequestParam(defaultValue = "20") int maxCards
        ) {
            return ResponseEntity.ok(service.startSession(maxCards));
        }

        @GetMapping("/sessions/{id}/next")
        public ResponseEntity<StudyCardDTO> getNextCard(@PathVariable Long id) {
            StudyCardDTO card = service.getNextCard(id);
            return card != null ? ResponseEntity.ok(card) : ResponseEntity.noContent().build();
        }

        @PostMapping("/sessions/{id}/rate")
        public ResponseEntity<StudyCardDTO> rateCard(
            @PathVariable Long id,
            @RequestBody RateCardRequestDTO request
        ) {
            ReviewRating rating = ReviewRating.valueOf(request.rating().toUpperCase());
            StudyCardDTO next = service.rateCard(id, request.lemmaId(), rating);
            return next != null ? ResponseEntity.ok(next) : ResponseEntity.noContent().build();
        }

        @PostMapping("/sessions/{id}/end")
        public ResponseEntity<SessionSummaryDTO> endSession(@PathVariable Long id) {
            return ResponseEntity.ok(service.endSession(id));
        }

        @GetMapping("/due-count")
        public ResponseEntity<DueCountDTO> getDueCount() {
            return ResponseEntity.ok(service.getDueCount());
        }
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -5

    # With backend running:
    curl -s http://localhost:8080/api/study/due-count
    # Returns: {"dueToday":0,"newCards":N}

    curl -s -X POST "http://localhost:8080/api/study/sessions?maxCards=5"
    # Returns StartSessionResponseDTO or 400 if no cards
  </verify>
  <done>All DTOs created. StudyController exposes 5 endpoints. mvn compile passes. API responds correctly.</done>
</task>

</tasks>

<verification>
1. V5 migration applied — all 4 tables exist in DB
2. `mvn compile -q` passes with no errors
3. GET /api/study/due-count returns {"dueToday":N,"newCards":N}
4. POST /api/study/sessions starts session and returns first card
5. POST /api/study/sessions/{id}/rate updates srs_state interval_days in DB
6. POST /api/study/sessions/{id}/end returns SessionSummaryDTO with retentionRate
7. After CORRECT: srs_state.interval_days increases, repetition_count increments
8. After INCORRECT: srs_state.interval_days = 1, ease_factor decreases to min 1.30
</verification>

<success_criteria>
All 5 REST endpoints work. SM-2 algorithm correctly updates srs_state after each rating. Session auto-completes when all cards reviewed. mvn compile clean.
</success_criteria>

<output>
After completion, create `.planning/phases/06-flashcards-basic-study/06-01-SUMMARY.md`
</output>
