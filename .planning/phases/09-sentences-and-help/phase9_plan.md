# Phase 9: Example Sentences & Help Page

## 1. Goal Summary

Phase 9 adds two distinct capabilities:

**Sentence Generation**: For every vocabulary entry, generate 4 natural Bulgarian example
sentences showing the word used in context. The entry for "искам да" illustrates the need —
the lemma alone tells you the canonical form, but seeing it used in real sentences
("Искам да отида на кино.") is essential for understanding how it actually behaves in speech.

Sentences are generated by **Qwen 2.5 14B** (already downloaded, 9 GB), stored
persistently, displayed on the vocabulary detail page, and optionally accessible during
study sessions.

**Help/FAQ Page**: A new tab in the main navigation providing a user guide explaining how
the app works — no backend changes required.

---

## 2. Database Changes (Flyway V10)

File: `backend/src/main/resources/db/migration/V10__add_example_sentences.sql`

```sql
CREATE TABLE example_sentences (
    id BIGSERIAL PRIMARY KEY,
    lemma_id BIGINT NOT NULL REFERENCES lemmas(id) ON DELETE CASCADE,
    bulgarian_text TEXT NOT NULL,
    english_translation TEXT NOT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_example_sentences_lemma_id ON example_sentences(lemma_id);

ALTER TABLE lemmas
    ADD COLUMN sentence_status VARCHAR(20) NOT NULL DEFAULT 'NONE';
-- Values: NONE, QUEUED, GENERATING, DONE, FAILED
```

Design rationale:
- Separate table (not a column) because each lemma gets multiple sentences
- `ON DELETE CASCADE` mirrors the inflections table pattern
- `sort_order` allows storing simplest sentence first
- `sentence_status` on lemmas makes it trivial to query "words with no sentences yet"

---

## 3. Backend Changes

### 3.1 New Enum: `SentenceStatus`

`com/vocab/bulgarian/domain/enums/SentenceStatus.java`
```java
public enum SentenceStatus { NONE, QUEUED, GENERATING, DONE, FAILED }
```

### 3.2 New Entity: `ExampleSentence`

`com/vocab/bulgarian/domain/ExampleSentence.java`
- `@Entity @Table(name = "example_sentences")`
- Fields: `id`, `bulgarianText` (TEXT), `englishTranslation` (TEXT), `sortOrder`, `lemma` (LAZY ManyToOne), `createdAt`
- `@PrePersist` sets `createdAt`

Add to `Lemma.java`:
```java
@OneToMany(mappedBy = "lemma", cascade = ALL, orphanRemoval = true)
@OrderBy("sortOrder ASC")
private List<ExampleSentence> exampleSentences = new ArrayList<>();

@Enumerated(EnumType.STRING)
@Column(name = "sentence_status", length = 20)
private SentenceStatus sentenceStatus = SentenceStatus.NONE;
```

### 3.3 DTOs

**New** `ExampleSentenceDTO`:
```java
public record ExampleSentenceDTO(Long id, String bulgarianText, String englishTranslation, int sortOrder) {}
```

**Update** `LemmaDetailDTO` — add:
```java
List<ExampleSentenceDTO> exampleSentences,
SentenceStatus sentenceStatus
```

**Update** `LemmaResponseDTO` — add:
```java
SentenceStatus sentenceStatus
```

### 3.4 Repository

**New** `ExampleSentenceRepository`:
```java
List<ExampleSentence> findByLemmaIdOrderBySortOrderAsc(Long lemmaId);
void deleteAllByLemmaId(Long lemmaId);
```

**Update** `LemmaRepository` — add:
```java
@Query("SELECT l FROM Lemma l WHERE l.sentenceStatus = com.vocab.bulgarian.domain.enums.SentenceStatus.NONE " +
       "AND l.processingStatus = com.vocab.bulgarian.domain.enums.ProcessingStatus.COMPLETED " +
       "AND l.reviewStatus = com.vocab.bulgarian.domain.enums.ReviewStatus.REVIEWED")
List<Lemma> findLemmasNeedingSentences(Pageable pageable);
```

**Note on JPA multi-bag fetch**: Do NOT use JOIN FETCH for both inflections and sentences on
the same lemma — this causes MultipleBagFetchException. Load sentences in a second query via
`ExampleSentenceRepository.findByLemmaIdOrderBySortOrderAsc(id)` separately from the
inflections fetch. The service layer composes them.

### 3.5 LLM DTO: `SentenceSet`

`com/vocab/bulgarian/llm/dto/SentenceSet.java`
```java
public record SentenceSet(
    @NotBlank String lemma,
    @NotEmpty List<SentenceEntry> sentences
) {
    public record SentenceEntry(
        @NotBlank String bulgarianText,
        @NotBlank String englishTranslation
    ) {}
}
```

Add `validateSentenceSet(SentenceSet s)` to `LlmOutputValidator` — check not null,
at least 2 sentences, each entry has non-blank text and translation.

### 3.6 LLM Config: Second ChatClient for Qwen 2.5 14B

In `LlmConfig.java` (or `OllamaConfig.java`), add a second bean:
```java
@Bean
@Qualifier("sentenceChatClient")
public ChatClient sentenceChatClient(ChatClient.Builder builder) {
    return builder
        .defaultSystem("You are a Bulgarian language teacher. Generate natural, correct " +
                       "Bulgarian example sentences. Respond ONLY in valid JSON.")
        .defaultOptions(OllamaChatOptions.builder()
            .withModel("qwen2.5:14b")
            .withTemperature(0.7f)  // higher for sentence variety
            .withNumCtx(4096)
            .build())
        .build();
}
```

In `application.yml` / `application-dev.yml`, add a second circuit breaker:
```yaml
resilience4j:
  circuitbreaker:
    instances:
      ollama-sentence:
        sliding-window-size: 5
        failure-rate-threshold: 60
        wait-duration-in-open-state: 30s
```

In `CacheConfig.java`, add `sentenceGeneration` cache (same TTL as other LLM caches).

### 3.7 New Service: `SentenceGenerationService`

`com/vocab/bulgarian/llm/service/SentenceGenerationService.java`

Follows `InflectionGenerationService` pattern exactly:
- Injects `@Qualifier("sentenceChatClient") ChatClient`
- `@Cacheable(value = "sentenceGeneration", key = "#lemma.trim().toLowerCase()")`
- `@CircuitBreaker(name = "ollama-sentence", fallbackMethod = "generateSentencesFallback")`
- Micrometer timers (success/failure)
- Async wrapper method

**Prompt template:**
```
Generate 4 natural Bulgarian example sentences for the word/phrase "{lemma}"
({partOfSpeech}, means "{translation}").

Requirements:
- Each sentence must clearly feature "{lemma}" used naturally
- Sentences should progress from simple to complex
- Include a mix of contexts (everyday conversation, questions, etc.)
- Bulgarian text must be grammatically correct
- Translations must be accurate English

Respond ONLY in this exact JSON format:
{
  "lemma": "{lemma}",
  "sentences": [
    {"bulgarianText": "...", "englishTranslation": "..."},
    {"bulgarianText": "...", "englishTranslation": "..."},
    {"bulgarianText": "...", "englishTranslation": "..."},
    {"bulgarianText": "...", "englishTranslation": "..."}
  ]
}
```

### 3.8 New Service: `SentenceService`

`com/vocab/bulgarian/service/SentenceService.java`

Follows `BackgroundProcessingService` two-transaction pattern:
```
generateSentences(lemmaId):
  TX: load lemma, set sentenceStatus=QUEUED, save, register afterCommit
  afterCommit: backgroundGenerateSentences(lemmaId)
  returns LemmaDetailDTO immediately

@Async("llmTaskExecutor")
backgroundGenerateSentences(lemmaId):
  TX: load lemma, set sentenceStatus=GENERATING, save
  call sentenceGenerationService.generateSentencesAsync(...).get()  [no TX held]
  TX: persist ExampleSentence entities, set sentenceStatus=DONE, save
  on error: TX: set sentenceStatus=FAILED, save
```

Also add `regenerateSentences(lemmaId)` — clears existing sentences, resets to QUEUED,
triggers background generation.

### 3.9 New Controller: `SentenceController`

`com/vocab/bulgarian/api/controller/SentenceController.java`

```
POST /api/vocabulary/{id}/sentences/generate     → 202 Accepted, LemmaDetailDTO
POST /api/vocabulary/{id}/sentences/regenerate   → 202 Accepted, LemmaDetailDTO
```

(A separate GET endpoint is not needed — sentences are returned inside `LemmaDetailDTO`
from the existing `GET /api/vocabulary/{id}` endpoint.)

### 3.10 Mapper and Service Updates

`LemmaMapper.toDetailDTO` — must accept sentences as a separate argument (to avoid the
multi-bag problem):
```java
LemmaDetailDTO toDetailDTO(Lemma lemma, List<ExampleSentenceDTO> sentences);
```

Or: load sentences in the service and set on a builder DTO after mapping. Either works;
the separate-argument approach is cleaner.

Update `VocabularyService.getVocabularyById`:
```java
Lemma lemma = lemmaRepository.findByIdWithInflections(id).orElseThrow(...);
List<ExampleSentenceDTO> sentences = exampleSentenceRepository
    .findByLemmaIdOrderBySortOrderAsc(id).stream()
    .map(lemmaMapper::toExampleSentenceDTO)
    .toList();
return lemmaMapper.toDetailDTO(lemma, sentences);
```

Apply same change everywhere `toDetailDTO` is called (reprocess, flag, updateReviewStatus, etc.).

---

## 4. Frontend Changes

### 4.1 Type Updates (`types.ts`)

```typescript
export type SentenceStatus = 'NONE' | 'QUEUED' | 'GENERATING' | 'DONE' | 'FAILED';

export interface ExampleSentenceDTO {
  id: number;
  bulgarianText: string;
  englishTranslation: string;
  sortOrder: number;
}

// Add to LemmaDetailDTO:
exampleSentences: ExampleSentenceDTO[];
sentenceStatus: SentenceStatus;

// Add to LemmaResponseDTO:
sentenceStatus: SentenceStatus;
```

### 4.2 New Hook: `useGenerateSentences`

`features/vocabulary/api/useGenerateSentences.ts` — follows `useReprocessVocabulary` pattern.

### 4.3 New Component: `ExampleSentencesSection`

`features/vocabulary/components/ExampleSentencesSection.tsx`

State machine based on `sentenceStatus`:
- `NONE` / `FAILED` → "Generate Example Sentences" button
- `QUEUED` / `GENERATING` → spinner + "Generating sentences…" text; polls `refetch()` every 3s
- `DONE` → numbered list of sentences, each with Bulgarian text (large, `lang="bg"`) +
  English translation + `<AudioPlayButton text={sentence.bulgarianText} />`;
  plus a subtle "Regenerate" link at the bottom

Polling: `useEffect` + `setInterval` checking `lemma.sentenceStatus`, clears when DONE or FAILED.
Mirrors existing polling in `VocabularyDetail` for `processingStatus`.

### 4.4 Update `VocabularyDetail`

Insert `<ExampleSentencesSection lemma={lemma} onGenerated={refetch} />` after the
Inflections section (sentences are enrichment, inflections are core grammar — show grammar first).

### 4.5 Help Page

New file: `frontend/src/features/help/HelpPage.tsx` — pure static JSX, no API calls.

Content sections (collapsible with `useState`):
- **What This App Is** — vocabulary tutor for Bulgarian lessons
- **Adding Vocabulary** — enter any word form, system detects lemma, processing takes ~30s
- **Inline Notes Syntax** — `пера (notes: verb - to wash)` in bulk add
- **Review Queue** — PENDING words won't appear in flashcards until REVIEWED
- **Study / Flashcards** — SM-2 SRS, what Correct/Incorrect/Skip does
- **Word Lists** — organising vocabulary by topic or lesson
- **Example Sentences** — what they are, how to generate them
- **Audio Playback** — TTS via edge-tts
- **Accented Forms** — stress marks (e.g. часа́), what they mean
- **Reprocess / Disambiguation** — when to use the hint field

Update `App.tsx`: add `'help'` to `AppView` union, add Help tab button, add render branch.

---

## 5. Implementation Sequence

### Plan 09-01: Backend

1. Write `V10__add_example_sentences.sql`
2. Create `SentenceStatus` enum
3. Create `ExampleSentence` entity; update `Lemma` entity
4. Create `ExampleSentenceRepository`; update `LemmaRepository`
5. Create `ExampleSentenceDTO`; update `LemmaDetailDTO`, `LemmaResponseDTO`
6. Create `SentenceSet` LLM DTO; add `validateSentenceSet` to `LlmOutputValidator`
7. Add `sentenceChatClient` bean (Qwen 2.5 14B) to `LlmConfig`; add circuit breaker + cache config
8. Create `SentenceGenerationService`
9. Create `SentenceService` (background two-transaction pattern)
10. Create `SentenceController`
11. Update `LemmaMapper` and all `VocabularyService` methods that call `toDetailDTO`
12. Run Flyway, test via curl: `POST /api/vocabulary/{id}/sentences/generate`

### Plan 09-02: Frontend + Help

1. Update `types.ts`
2. Create `useGenerateSentences` hook
3. Create `ExampleSentencesSection` component
4. Insert into `VocabularyDetail`
5. Create `HelpPage.tsx`
6. Update `App.tsx` (add Help tab)
7. End-to-end UAT — add word, generate sentences, verify audio works on sentences

---

## 6. Open Questions for User to Decide

### Q1: Automatic vs. On-Demand Sentence Generation?
**Recommended**: On-demand (button in UI). Keeps initial pipeline unchanged; Qwen 14B adds
60–90s to an already-slow pipeline; sentences aren't needed for the word to be REVIEWED.

**Alternative**: Auto-trigger after processing completes in `BackgroundProcessingService`.

### Q2: Qwen 2.5 14B vs. 7B?
Both are downloaded. 14B ≈ 60–90s, 7B ≈ 30–45s on M4 Max. 14B produces noticeably better
output quality for generation tasks.
**Recommended**: 14B.

### Q3: Sentence Audio in Flashcards?
Adding sentences to flashcard backs requires extending `StudyCardDTO` and `StudyController`.
Scope question: include in Phase 9 Plan 02, or defer to Phase 10?
**Recommended**: Defer to Phase 10 — keep Phase 9 focused.

### Q4: Backfill for Existing Words?
Options: (a) "Generate All Missing" button in vocabulary list, (b) config-flag startup
backfill, (c) per-word from the detail page only.
**Recommended**: (a) — a single button in the vocabulary list that triggers batch backfill
(iterate REVIEWED words with `sentenceStatus=NONE`, fire off background tasks).

### Q5: Sentence Count?
Currently 4. Adjustable in the prompt. The right balance is 3–5 — enough for variety,
not so many it takes forever.
**Recommended**: 4 (default in prompt, can tune later).

---

## 7. Critical Files to Reference During Implementation

| File | Why |
|------|-----|
| `domain/Inflection.java` | Pattern for `ExampleSentence` entity |
| `service/BackgroundProcessingService.java` | Two-transaction async pattern for `SentenceService` |
| `llm/service/InflectionGenerationService.java` | Cacheable + circuit-breaker + timer pattern for `SentenceGenerationService` |
| `llm/config/LlmConfig.java` | Add second `sentenceChatClient` bean here |
| `api/controller/VocabularyController.java` | Pattern for `SentenceController` |
| `features/vocabulary/components/VocabularyDetail.tsx` | Insert `<ExampleSentencesSection>` here |
| `features/vocabulary/components/InflectionsTable.tsx` | Pattern for display component |
