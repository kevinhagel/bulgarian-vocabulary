---
phase: 07-word-lists
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/main/resources/db/migration/V6__add_word_lists.sql
  - backend/src/main/java/com/vocab/bulgarian/lists/domain/WordList.java
  - backend/src/main/java/com/vocab/bulgarian/lists/repository/WordListRepository.java
  - backend/src/main/java/com/vocab/bulgarian/lists/dto/WordListSummaryDTO.java
  - backend/src/main/java/com/vocab/bulgarian/lists/dto/WordListDetailDTO.java
  - backend/src/main/java/com/vocab/bulgarian/lists/dto/CreateWordListRequestDTO.java
  - backend/src/main/java/com/vocab/bulgarian/lists/dto/RenameWordListRequestDTO.java
  - backend/src/main/java/com/vocab/bulgarian/lists/dto/AddLemmaRequestDTO.java
  - backend/src/main/java/com/vocab/bulgarian/lists/service/WordListService.java
  - backend/src/main/java/com/vocab/bulgarian/lists/controller/WordListController.java
  - backend/src/main/java/com/vocab/bulgarian/study/service/StudySessionService.java
  - backend/src/main/java/com/vocab/bulgarian/api/exception/GlobalExceptionHandler.java
autonomous: true

must_haves:
  truths:
    - "V6 migration creates word_lists and word_list_members tables"
    - "GET /api/lists returns all lists with lemma count"
    - "POST /api/lists creates a named list"
    - "GET /api/lists/{id} returns list detail with all member lemmas (LemmaResponseDTO)"
    - "PUT /api/lists/{id} renames the list"
    - "DELETE /api/lists/{id} deletes the list (cascades members)"
    - "POST /api/lists/{id}/members adds a lemma to the list (idempotent)"
    - "DELETE /api/lists/{id}/members/{lemmaId} removes a lemma from the list"
    - "POST /api/lists/{id}/sessions?mode=DUE starts SRS-filtered session (due+new cards from list only)"
    - "POST /api/lists/{id}/sessions?mode=ALL starts practice session (all list members regardless of SRS)"
    - "409 Conflict returned when creating a vocabulary entry that already exists (text+source unique violation)"
    - "mvn compile -q passes"
  artifacts:
    - path: "backend/src/main/resources/db/migration/V6__add_word_lists.sql"
      provides: "Word list schema"
      contains: "word_lists"
    - path: "backend/src/main/java/com/vocab/bulgarian/lists/service/WordListService.java"
      provides: "List CRUD + member management + session start"
      contains: "startListSession"
    - path: "backend/src/main/java/com/vocab/bulgarian/lists/controller/WordListController.java"
      provides: "REST API for word lists"
      contains: "/api/lists"
---

<objective>
Build the complete word lists backend: database schema, JPA entity, service, and REST controller. Also adds list-specific study session support (both SRS-filtered and practice-all modes) and proper 409 conflict handling for duplicate vocabulary creation.

Purpose: Enables creating named study lists, managing membership, and studying subsets of vocabulary.
Output: 8 REST endpoints working. List-specific sessions reuse the existing study session infrastructure.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: V6 migration — word_lists and word_list_members tables</name>
  <files>
    backend/src/main/resources/db/migration/V6__add_word_lists.sql
  </files>
  <action>
    Create `backend/src/main/resources/db/migration/V6__add_word_lists.sql`:

    ```sql
    -- Named word lists for organizing vocabulary into study sets
    CREATE TABLE word_lists (
        id          BIGSERIAL PRIMARY KEY,
        name        VARCHAR(100) NOT NULL,
        created_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        updated_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    );

    -- Many-to-many: a lemma can be in multiple lists, a list can have many lemmas
    CREATE TABLE word_list_members (
        list_id   BIGINT NOT NULL REFERENCES word_lists(id) ON DELETE CASCADE,
        lemma_id  BIGINT NOT NULL REFERENCES lemmas(id) ON DELETE CASCADE,
        added_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        PRIMARY KEY (list_id, lemma_id)
    );

    CREATE INDEX idx_word_list_members_lemma ON word_list_members(lemma_id);
    CREATE INDEX idx_word_list_members_list  ON word_list_members(list_id);
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && export POSTGRES_PASSWORD='BG_Vocab_2026_PostgreSQL!' && mvn flyway:migrate -q 2>&1 | tail -5
    mvn flyway:info 2>&1 | grep V6
    # Shows V6 as Success
  </verify>
  <done>V6 migration applied. word_lists and word_list_members tables exist.</done>
</task>

<task type="auto">
  <name>Task 2: WordList JPA entity and repository</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/lists/domain/WordList.java
    backend/src/main/java/com/vocab/bulgarian/lists/repository/WordListRepository.java
  </files>
  <action>
    **WordList entity** — use `@ManyToMany` with `@JoinTable`. Package: `com.vocab.bulgarian.lists.domain`.

    ```java
    package com.vocab.bulgarian.lists.domain;

    import com.vocab.bulgarian.domain.Lemma;
    import jakarta.persistence.*;
    import java.time.ZonedDateTime;
    import java.util.ArrayList;
    import java.util.List;

    @Entity
    @Table(name = "word_lists")
    public class WordList {

        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @Column(nullable = false, length = 100)
        private String name;

        @ManyToMany(fetch = FetchType.LAZY)
        @JoinTable(
            name = "word_list_members",
            joinColumns = @JoinColumn(name = "list_id"),
            inverseJoinColumns = @JoinColumn(name = "lemma_id")
        )
        private List<Lemma> lemmas = new ArrayList<>();

        @Column(name = "created_at", nullable = false, updatable = false)
        private ZonedDateTime createdAt = ZonedDateTime.now();

        @Column(name = "updated_at", nullable = false)
        private ZonedDateTime updatedAt = ZonedDateTime.now();

        @PreUpdate
        void onUpdate() { this.updatedAt = ZonedDateTime.now(); }

        public Long getId() { return id; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public List<Lemma> getLemmas() { return lemmas; }
        public ZonedDateTime getCreatedAt() { return createdAt; }
        public ZonedDateTime getUpdatedAt() { return updatedAt; }
    }
    ```

    **WordListRepository** — package: `com.vocab.bulgarian.lists.repository`.

    Needs:
    - `findAllWithLemmaCount()` for the list overview (JPQL COUNT to avoid loading all lemmas)
    - `findByIdWithLemmas()` for detail view (JOIN FETCH to avoid N+1)
    - `findLemmaIdsByListId()` for session start (just IDs, no full entity load)
    - `existsByListIdAndLemmaId()` for idempotent add

    ```java
    package com.vocab.bulgarian.lists.repository;

    import com.vocab.bulgarian.lists.domain.WordList;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Modifying;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.query.Param;

    import java.util.List;
    import java.util.Optional;

    public interface WordListRepository extends JpaRepository<WordList, Long> {

        // Returns all lists ordered by name — no lemma loading (summary only)
        @Query("SELECT wl FROM WordList wl ORDER BY wl.name ASC")
        List<WordList> findAllOrderByName();

        // JOIN FETCH lemmas for detail view
        @Query("SELECT wl FROM WordList wl LEFT JOIN FETCH wl.lemmas WHERE wl.id = :id")
        Optional<WordList> findByIdWithLemmas(@Param("id") Long id);

        // Count of lemmas per list (for summary DTO without loading lemmas)
        @Query("SELECT SIZE(wl.lemmas) FROM WordList wl WHERE wl.id = :id")
        int countLemmasByListId(@Param("id") Long id);

        // Lemma IDs for session start (efficient — no entity loading)
        @Query("SELECT l.id FROM WordList wl JOIN wl.lemmas l WHERE wl.id = :listId")
        List<Long> findLemmaIdsByListId(@Param("listId") Long listId);

        // Check membership for idempotent add
        @Query(value = "SELECT EXISTS(SELECT 1 FROM word_list_members WHERE list_id = :listId AND lemma_id = :lemmaId)",
               nativeQuery = true)
        boolean existsMembership(@Param("listId") Long listId, @Param("lemmaId") Long lemmaId);

        // Native insert — avoids loading the full entity just to add a member
        @Modifying
        @Query(value = "INSERT INTO word_list_members(list_id, lemma_id) VALUES (:listId, :lemmaId) ON CONFLICT DO NOTHING",
               nativeQuery = true)
        void addMember(@Param("listId") Long listId, @Param("lemmaId") Long lemmaId);

        // Native delete for member removal
        @Modifying
        @Query(value = "DELETE FROM word_list_members WHERE list_id = :listId AND lemma_id = :lemmaId",
               nativeQuery = true)
        void removeMember(@Param("listId") Long listId, @Param("lemmaId") Long lemmaId);
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -10
  </verify>
  <done>WordList entity and WordListRepository compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: DTOs (all records)</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/lists/dto/WordListSummaryDTO.java
    backend/src/main/java/com/vocab/bulgarian/lists/dto/WordListDetailDTO.java
    backend/src/main/java/com/vocab/bulgarian/lists/dto/CreateWordListRequestDTO.java
    backend/src/main/java/com/vocab/bulgarian/lists/dto/RenameWordListRequestDTO.java
    backend/src/main/java/com/vocab/bulgarian/lists/dto/AddLemmaRequestDTO.java
  </files>
  <action>
    All DTOs are Java records. Package: `com.vocab.bulgarian.lists.dto`.

    ```java
    // WordListSummaryDTO.java — used in GET /api/lists (overview, no member loading)
    package com.vocab.bulgarian.lists.dto;
    import java.time.ZonedDateTime;
    public record WordListSummaryDTO(Long id, String name, int lemmaCount, ZonedDateTime createdAt) {}

    // WordListDetailDTO.java — used in GET /api/lists/{id} (includes member lemmas)
    package com.vocab.bulgarian.lists.dto;
    import com.vocab.bulgarian.api.dto.LemmaResponseDTO;
    import java.time.ZonedDateTime;
    import java.util.List;
    public record WordListDetailDTO(Long id, String name, List<LemmaResponseDTO> lemmas, ZonedDateTime createdAt) {}

    // CreateWordListRequestDTO.java
    package com.vocab.bulgarian.lists.dto;
    import jakarta.validation.constraints.NotBlank;
    import jakarta.validation.constraints.Size;
    public record CreateWordListRequestDTO(
        @NotBlank @Size(min = 1, max = 100) String name
    ) {}

    // RenameWordListRequestDTO.java
    package com.vocab.bulgarian.lists.dto;
    import jakarta.validation.constraints.NotBlank;
    import jakarta.validation.constraints.Size;
    public record RenameWordListRequestDTO(
        @NotBlank @Size(min = 1, max = 100) String name
    ) {}

    // AddLemmaRequestDTO.java
    package com.vocab.bulgarian.lists.dto;
    import jakarta.validation.constraints.NotNull;
    public record AddLemmaRequestDTO(@NotNull Long lemmaId) {}
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -5
  </verify>
  <done>All 5 DTOs compile. They are Java records, no Lombok.</done>
</task>

<task type="auto">
  <name>Task 4: WordListService</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/lists/service/WordListService.java
  </files>
  <action>
    Package: `com.vocab.bulgarian.lists.service`. Inject `WordListRepository`, `LemmaRepository`, `SrsStateRepository`, `StudySessionService`.

    Key methods:
    - `getAllLists()` — returns `List<WordListSummaryDTO>` using `findAllOrderByName()`. For each list, count lemmas separately (no JOIN FETCH needed for summary).
    - `getListDetail(id)` — uses `findByIdWithLemmas()`, maps lemmas to `LemmaResponseDTO` using `LemmaMapper`.
    - `createList(request)` — creates `WordList`, saves, returns `WordListSummaryDTO`.
    - `renameList(id, request)` — loads, sets name, saves.
    - `deleteList(id)` — `deleteById`. Cascade in DB handles members.
    - `addLemma(listId, lemmaId)` — verify list and lemma exist, call `repo.addMember()` (idempotent via ON CONFLICT DO NOTHING).
    - `removeLemma(listId, lemmaId)` — call `repo.removeMember()`.
    - `startListSession(listId, mode, maxCards)` — see below.

    `startListSession` logic:
    - Load `listLemmaIds = repo.findLemmaIdsByListId(listId)`.
    - If empty: throw `IllegalStateException("List is empty — add vocabulary before studying")`.
    - If `mode == ALL`: use all listLemmaIds (shuffle, cap at maxCards). Ensure SrsState exists for each. Build session.
    - If `mode == DUE`: filter `srsRepo.findDueCards(today)` to only those in listLemmaIds. Also find new cards (no SrsState) that are in listLemmaIds, cap at MAX_NEW_CARDS. Merge, shuffle, cap. If empty: throw `IllegalStateException("No due or new cards in this list. Try Practice All mode.")`.
    - In both cases: delegate session building to a shared private method (or call into StudySessionService). Return `StartSessionResponseDTO`.

    **Important**: `startListSession` should NOT be in `StudySessionService` to keep concerns separated. Instead, extract the session-building logic from `StudySessionService` into a private helper, then call it from both services — OR duplicate the small session-building block (it's ~15 lines). Duplication is acceptable here to avoid coupling the two services.

    The session-building block (duplicate from StudySessionService):
    ```java
    private StartSessionResponseDTO buildSession(List<Long> sessionIds) {
        StudySession session = new StudySession();
        session.setCardCount(sessionIds.size());
        session = sessionRepo.save(session);
        for (int i = 0; i < sessionIds.size(); i++) {
            Lemma lemma = lemmaRepo.getReferenceById(sessionIds.get(i));
            SessionCard card = new SessionCard();
            card.setSession(session);
            card.setLemma(lemma);
            card.setPosition(i);
            cardRepo.save(card);
        }
        StudyCardDTO firstCard = cardRepo.findFirstUnreviewed(session.getId())
            .map(sc -> new StudyCardDTO(sc.getLemma().getId(), sc.getLemma().getText(),
                                        sc.getLemma().getTranslation(),
                                        (long) session.getCardCount()))
            .orElse(null);
        return new StartSessionResponseDTO(session.getId(), session.getCardCount(), firstCard);
    }
    ```

    Inject into WordListService: `StudySessionRepository`, `SessionCardRepository`, `SrsStateRepository`, `LemmaRepository`, `LemmaMapper`.

    Full class structure:
    ```java
    package com.vocab.bulgarian.lists.service;

    import com.vocab.bulgarian.api.dto.LemmaResponseDTO;
    import com.vocab.bulgarian.api.mapper.LemmaMapper;
    import com.vocab.bulgarian.domain.Lemma;
    import com.vocab.bulgarian.lists.domain.WordList;
    import com.vocab.bulgarian.lists.dto.*;
    import com.vocab.bulgarian.lists.repository.WordListRepository;
    import com.vocab.bulgarian.repository.LemmaRepository;
    import com.vocab.bulgarian.study.domain.*;
    import com.vocab.bulgarian.study.dto.*;
    import com.vocab.bulgarian.study.repository.*;
    import jakarta.persistence.EntityNotFoundException;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import java.time.LocalDate;
    import java.util.*;

    @Service
    @Transactional
    public class WordListService {

        private static final int MAX_NEW_CARDS_PER_SESSION = 10;

        private final WordListRepository listRepo;
        private final LemmaRepository lemmaRepo;
        private final SrsStateRepository srsRepo;
        private final StudySessionRepository sessionRepo;
        private final SessionCardRepository cardRepo;
        private final LemmaMapper lemmaMapper;

        public WordListService(WordListRepository listRepo, LemmaRepository lemmaRepo,
                               SrsStateRepository srsRepo, StudySessionRepository sessionRepo,
                               SessionCardRepository cardRepo, LemmaMapper lemmaMapper) {
            this.listRepo = listRepo;
            this.lemmaRepo = lemmaRepo;
            this.srsRepo = srsRepo;
            this.sessionRepo = sessionRepo;
            this.cardRepo = cardRepo;
            this.lemmaMapper = lemmaMapper;
        }

        @Transactional(readOnly = true)
        public List<WordListSummaryDTO> getAllLists() {
            return listRepo.findAllOrderByName().stream()
                .map(wl -> new WordListSummaryDTO(
                    wl.getId(), wl.getName(),
                    listRepo.countLemmasByListId(wl.getId()),
                    wl.getCreatedAt()))
                .toList();
        }

        @Transactional(readOnly = true)
        public WordListDetailDTO getListDetail(Long id) {
            WordList wl = listRepo.findByIdWithLemmas(id)
                .orElseThrow(() -> new EntityNotFoundException("List not found: " + id));
            List<LemmaResponseDTO> lemmas = wl.getLemmas().stream()
                .map(lemmaMapper::toResponseDTO)
                .sorted(Comparator.comparing(LemmaResponseDTO::text))
                .toList();
            return new WordListDetailDTO(wl.getId(), wl.getName(), lemmas, wl.getCreatedAt());
        }

        public WordListSummaryDTO createList(CreateWordListRequestDTO request) {
            WordList wl = new WordList();
            wl.setName(request.name().strip());
            wl = listRepo.save(wl);
            return new WordListSummaryDTO(wl.getId(), wl.getName(), 0, wl.getCreatedAt());
        }

        public WordListSummaryDTO renameList(Long id, RenameWordListRequestDTO request) {
            WordList wl = listRepo.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("List not found: " + id));
            wl.setName(request.name().strip());
            listRepo.save(wl);
            return new WordListSummaryDTO(wl.getId(), wl.getName(),
                listRepo.countLemmasByListId(id), wl.getCreatedAt());
        }

        public void deleteList(Long id) {
            if (!listRepo.existsById(id)) {
                throw new EntityNotFoundException("List not found: " + id);
            }
            listRepo.deleteById(id);
        }

        public void addLemma(Long listId, Long lemmaId) {
            if (!listRepo.existsById(listId)) throw new EntityNotFoundException("List not found: " + listId);
            if (!lemmaRepo.existsById(lemmaId)) throw new EntityNotFoundException("Lemma not found: " + lemmaId);
            listRepo.addMember(listId, lemmaId);  // ON CONFLICT DO NOTHING — idempotent
        }

        public void removeLemma(Long listId, Long lemmaId) {
            if (!listRepo.existsById(listId)) throw new EntityNotFoundException("List not found: " + listId);
            listRepo.removeMember(listId, lemmaId);
        }

        public StartSessionResponseDTO startListSession(Long listId, String mode, int maxCards) {
            List<Long> listLemmaIds = listRepo.findLemmaIdsByListId(listId);
            if (listLemmaIds.isEmpty()) {
                throw new IllegalStateException("List is empty — add vocabulary before studying.");
            }

            Set<Long> listSet = new HashSet<>(listLemmaIds);
            List<Long> sessionIds;

            if ("ALL".equalsIgnoreCase(mode)) {
                // Practice mode: all list members, shuffled, capped
                sessionIds = new ArrayList<>(listLemmaIds);
                Collections.shuffle(sessionIds);
                sessionIds = sessionIds.stream().limit(maxCards).toList();
            } else {
                // DUE mode: SRS-filtered to list members only
                List<Long> dueIds = srsRepo.findDueCards(LocalDate.now()).stream()
                    .map(s -> s.getLemma().getId())
                    .filter(listSet::contains)
                    .toList();
                List<Long> newIds = srsRepo.findLemmaIdsWithoutSrsState().stream()
                    .filter(listSet::contains)
                    .limit(MAX_NEW_CARDS_PER_SESSION)
                    .toList();
                Set<Long> merged = new LinkedHashSet<>(dueIds);
                merged.addAll(newIds);
                sessionIds = new ArrayList<>(merged);
                Collections.shuffle(sessionIds);
                sessionIds = sessionIds.stream().limit(maxCards).toList();
                if (sessionIds.isEmpty()) {
                    throw new IllegalStateException(
                        "No due or new cards in this list. Try Practice All mode.");
                }
            }

            // Ensure SrsState exists for new cards
            for (Long lemmaId : sessionIds) {
                if (srsRepo.findByLemmaId(lemmaId).isEmpty()) {
                    SrsState state = new SrsState();
                    state.setLemma(lemmaRepo.getReferenceById(lemmaId));
                    srsRepo.save(state);
                }
            }

            return buildSession(sessionIds);
        }

        private StartSessionResponseDTO buildSession(List<Long> sessionIds) {
            StudySession session = new StudySession();
            session.setCardCount(sessionIds.size());
            session = sessionRepo.save(session);
            for (int i = 0; i < sessionIds.size(); i++) {
                Lemma lemma = lemmaRepo.getReferenceById(sessionIds.get(i));
                SessionCard card = new SessionCard();
                card.setSession(session);
                card.setLemma(lemma);
                card.setPosition(i);
                cardRepo.save(card);
            }
            final Long sessionId = session.getId();
            final int cardCount = session.getCardCount();
            StudyCardDTO firstCard = cardRepo.findFirstUnreviewed(sessionId)
                .map(sc -> new StudyCardDTO(
                    sc.getLemma().getId(), sc.getLemma().getText(),
                    sc.getLemma().getTranslation(), (long) cardCount))
                .orElse(null);
            return new StartSessionResponseDTO(sessionId, cardCount, firstCard);
        }
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -10
  </verify>
  <done>WordListService compiles. All list management and session start logic implemented.</done>
</task>

<task type="auto">
  <name>Task 5: WordListController and 409 conflict handling</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/lists/controller/WordListController.java
    backend/src/main/java/com/vocab/bulgarian/api/exception/GlobalExceptionHandler.java
  </files>
  <action>
    **WordListController** — package: `com.vocab.bulgarian.lists.controller`.

    ```java
    package com.vocab.bulgarian.lists.controller;

    import com.vocab.bulgarian.lists.dto.*;
    import com.vocab.bulgarian.lists.service.WordListService;
    import com.vocab.bulgarian.study.dto.StartSessionResponseDTO;
    import jakarta.validation.Valid;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;

    import java.util.List;

    @RestController
    @RequestMapping("/api/lists")
    public class WordListController {

        private final WordListService service;

        public WordListController(WordListService service) {
            this.service = service;
        }

        @GetMapping
        public ResponseEntity<List<WordListSummaryDTO>> getAllLists() {
            return ResponseEntity.ok(service.getAllLists());
        }

        @PostMapping
        public ResponseEntity<WordListSummaryDTO> createList(
                @Valid @RequestBody CreateWordListRequestDTO request) {
            return ResponseEntity.status(HttpStatus.CREATED).body(service.createList(request));
        }

        @GetMapping("/{id}")
        public ResponseEntity<WordListDetailDTO> getListDetail(@PathVariable Long id) {
            return ResponseEntity.ok(service.getListDetail(id));
        }

        @PutMapping("/{id}")
        public ResponseEntity<WordListSummaryDTO> renameList(
                @PathVariable Long id,
                @Valid @RequestBody RenameWordListRequestDTO request) {
            return ResponseEntity.ok(service.renameList(id, request));
        }

        @DeleteMapping("/{id}")
        public ResponseEntity<Void> deleteList(@PathVariable Long id) {
            service.deleteList(id);
            return ResponseEntity.noContent().build();
        }

        @PostMapping("/{id}/members")
        public ResponseEntity<Void> addLemma(
                @PathVariable Long id,
                @Valid @RequestBody AddLemmaRequestDTO request) {
            service.addLemma(id, request.lemmaId());
            return ResponseEntity.noContent().build();
        }

        @DeleteMapping("/{id}/members/{lemmaId}")
        public ResponseEntity<Void> removeLemma(
                @PathVariable Long id,
                @PathVariable Long lemmaId) {
            service.removeLemma(id, lemmaId);
            return ResponseEntity.noContent().build();
        }

        @PostMapping("/{id}/sessions")
        public ResponseEntity<StartSessionResponseDTO> startListSession(
                @PathVariable Long id,
                @RequestParam(defaultValue = "DUE") String mode,
                @RequestParam(defaultValue = "20") int maxCards) {
            return ResponseEntity.ok(service.startListSession(id, mode, maxCards));
        }
    }
    ```

    **Update GlobalExceptionHandler** — add 409 Conflict handling for duplicate vocabulary entries.
    Read the existing GlobalExceptionHandler first, then add a handler for `DataIntegrityViolationException`:

    ```java
    import org.springframework.dao.DataIntegrityViolationException;

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ProblemDetail handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        log.warn("Data integrity violation: {}", ex.getMostSpecificCause().getMessage());
        ProblemDetail problem = ProblemDetail.forStatus(HttpStatus.CONFLICT);
        problem.setDetail("A vocabulary entry with this word already exists.");
        return problem;
    }
    ```

    Add the import and this method to the existing `GlobalExceptionHandler` class.
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/backend && mvn compile -q 2>&1 | tail -5

    # With backend running:
    curl -s http://localhost:8080/api/lists | jq .
    # Returns []

    curl -s -X POST http://localhost:8080/api/lists \
      -H 'Content-Type: application/json' \
      -d '{"name":"Elena Lesson 1"}' | jq .
    # Returns {"id":1,"name":"Elena Lesson 1","lemmaCount":0,...}

    curl -s http://localhost:8080/api/lists/1 | jq .
    # Returns detail with empty lemmas array
  </verify>
  <done>All 8 REST endpoints live. 409 Conflict returned for duplicate vocabulary. mvn compile clean.</done>
</task>

</tasks>

<verification>
1. V6 migration applied — word_lists and word_list_members tables exist
2. `mvn compile -q` passes with no errors
3. GET /api/lists returns empty array []
4. POST /api/lists creates a list, returns 201 with WordListSummaryDTO
5. GET /api/lists/{id} returns list with empty lemmas array
6. PUT /api/lists/{id} renames the list
7. DELETE /api/lists/{id} returns 204 and removes the list
8. POST /api/lists/{id}/members adds a lemma (idempotent)
9. DELETE /api/lists/{id}/members/{lemmaId} removes a lemma
10. POST /api/lists/{id}/sessions?mode=ALL with a non-empty list starts a session
11. POST /api/lists/{id}/sessions?mode=DUE with no due cards returns 400 with helpful message
12. Duplicate vocabulary POST returns 409 Conflict
</verification>

<success_criteria>
All 8 list endpoints work. List-specific sessions start in both DUE and ALL modes. 409 returned for duplicate vocabulary. mvn compile clean.
</success_criteria>

<output>
After completion, create `.planning/phases/07-word-lists/07-01-SUMMARY.md`
</output>
