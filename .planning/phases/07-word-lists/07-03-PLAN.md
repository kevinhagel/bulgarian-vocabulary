---
phase: 07-word-lists
plan: 03
type: execute
wave: 3
depends_on: [07-02]
files_modified:
  - frontend/src/features/lists/components/AddVocabularyToList.tsx
  - frontend/src/features/lists/api/useStartListSession.ts
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Add Vocabulary button on ListDetail opens AddVocabularyToList sheet/modal"
    - "User enters words one per line in a textarea (Bulgarian Cyrillic keyboard friendly)"
    - "Each word is submitted as POST /api/vocabulary then POST /api/lists/{id}/members"
    - "Per-word status shown: pending → processing → added / already exists / failed"
    - "409 Conflict (word already exists) is handled: search for existing lemma and add to list"
    - "Study Due button calls POST /api/lists/{id}/sessions?mode=DUE, starts study tab session"
    - "Practice All button calls POST /api/lists/{id}/sessions?mode=ALL, starts study tab session"
    - "After list session starts, app switches to Study tab with FlashcardView active"
    - "npx tsc --noEmit passes"
    - "npm run build succeeds"
  artifacts:
    - path: "frontend/src/features/lists/components/AddVocabularyToList.tsx"
      provides: "Batch vocabulary entry sheet for adding words to a list"
      contains: "textarea"
    - path: "frontend/src/features/lists/api/useStartListSession.ts"
      provides: "Mutation hook for POST /api/lists/{id}/sessions"
      contains: "useStartListSession"
---

<objective>
Wire the two remaining list interactions: batch vocabulary entry and list-specific study sessions.

Batch entry: user types Bulgarian word forms (one per line), app creates vocabulary entries and adds them to the list, showing per-word status. 409 duplicates are resolved by searching existing vocab and adding to list.

Study integration: Study Due / Practice All launch the same FlashcardView used for global study, reusing all existing study infrastructure. App switches to Study tab automatically.

Output: Full Phase 7 feature complete. All 6 success criteria met.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: useStartListSession hook</name>
  <files>
    frontend/src/features/lists/api/useStartListSession.ts
  </files>
  <action>
    ```typescript
    import { useMutation } from '@tanstack/react-query';
    import api from '@/lib/api';
    import type { StartSessionResponseDTO } from '@/features/study/types';

    interface StartListSessionParams {
      listId: number;
      mode: 'DUE' | 'ALL';
      maxCards?: number;
    }

    export function useStartListSession() {
      return useMutation<StartSessionResponseDTO, Error, StartListSessionParams>({
        mutationFn: async ({ listId, mode, maxCards = 20 }) => {
          const response = await api.post<StartSessionResponseDTO>(
            `/lists/${listId}/sessions?mode=${mode}&maxCards=${maxCards}`
          );
          return response.data;
        },
      });
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/frontend && npx tsc --noEmit 2>&1 | tail -5
  </verify>
  <done>useStartListSession hook created and compiles.</done>
</task>

<task type="auto">
  <name>Task 2: AddVocabularyToList component</name>
  <files>
    frontend/src/features/lists/components/AddVocabularyToList.tsx
  </files>
  <action>
    This component is shown as a full-screen sheet (Modal wrapper) when "Add Vocabulary" is tapped.

    **UX flow:**
    1. Large textarea with placeholder (Bulgarian Cyrillic-friendly input)
    2. User types word forms, one per line: `чете\nказвам\nказвам се`
    3. "Add All" button processes each word:
       a. `POST /api/vocabulary` with `{ wordForm: word, translation: '' }`
       b. On 201: `POST /api/lists/{listId}/members` with returned lemma id
       c. On 409 (duplicate): `GET /api/vocabulary/search?q=word` → take first result → `POST /api/lists/{listId}/members`
       d. On other error: mark as failed
    4. Per-word status list shows results as they complete
    5. "Done" closes the sheet and refetches list detail

    **State:** `wordStatuses: Array<{ word: string; status: 'pending'|'adding'|'added'|'duplicate_found'|'failed'; lemmaText?: string }>`

    Process words sequentially (not parallel) to avoid hammering the backend and to show clear per-word progress.

    ```tsx
    import { useState } from 'react';
    import { useQueryClient } from '@tanstack/react-query';
    import api from '@/lib/api';
    import { Modal } from '@/components/ui/Modal';
    import type { LemmaDetailDTO } from '@/features/vocabulary/types';

    interface WordStatus {
      word: string;
      status: 'pending' | 'adding' | 'added' | 'duplicate_found' | 'failed';
      lemmaText?: string;
      error?: string;
    }

    interface Props {
      listId: number;
      onClose: () => void;
    }

    export function AddVocabularyToList({ listId, onClose }: Props) {
      const [input, setInput] = useState('');
      const [statuses, setStatuses] = useState<WordStatus[]>([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const queryClient = useQueryClient();

      const parseWords = (text: string): string[] =>
        text.split('\n')
          .map(w => w.trim())
          .filter(w => w.length > 0);

      const updateStatus = (index: number, update: Partial<WordStatus>) =>
        setStatuses(prev => prev.map((s, i) => i === index ? { ...s, ...update } : s));

      const processWords = async () => {
        const words = parseWords(input);
        if (words.length === 0) return;

        setIsProcessing(true);
        const initial: WordStatus[] = words.map(w => ({ word: w, status: 'pending' }));
        setStatuses(initial);

        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          updateStatus(i, { status: 'adding' });

          try {
            // Try to create vocabulary
            let lemmaId: number;
            let lemmaText: string;

            try {
              const createRes = await api.post<LemmaDetailDTO>('/vocabulary', {
                wordForm: word,
                translation: '',
              });
              lemmaId = createRes.data.id;
              lemmaText = createRes.data.text;
            } catch (createErr: any) {
              if (createErr?.response?.status === 409) {
                // Word already exists — find it by search
                const searchRes = await api.get<LemmaDetailDTO[]>(
                  `/vocabulary/search?q=${encodeURIComponent(word)}`
                );
                if (searchRes.data.length === 0) {
                  updateStatus(i, { status: 'failed', error: 'Word not found after duplicate error' });
                  continue;
                }
                lemmaId = searchRes.data[0].id;
                lemmaText = searchRes.data[0].text;
                updateStatus(i, { status: 'duplicate_found', lemmaText });
              } else {
                throw createErr;
              }
            }

            // Add to list (idempotent)
            await api.post(`/lists/${listId}/members`, { lemmaId });
            updateStatus(i, { status: 'added', lemmaText });

          } catch {
            updateStatus(i, { status: 'failed', error: 'Failed to add' });
          }
        }

        setIsProcessing(false);
        // Refresh the list detail
        queryClient.invalidateQueries({ queryKey: ['lists', listId] });
        queryClient.invalidateQueries({ queryKey: ['lists'] });
      };

      const statusIcon = (status: WordStatus['status']) => {
        switch (status) {
          case 'pending': return '○';
          case 'adding': return '⋯';
          case 'added': return '✓';
          case 'duplicate_found': return '✓';
          case 'failed': return '✗';
        }
      };

      const statusColor = (status: WordStatus['status']) => {
        switch (status) {
          case 'added': return 'text-green-600';
          case 'duplicate_found': return 'text-blue-500';
          case 'failed': return 'text-red-500';
          case 'adding': return 'text-orange-500';
          default: return 'text-gray-400';
        }
      };

      const statusLabel = (s: WordStatus) => {
        switch (s.status) {
          case 'adding': return 'Adding…';
          case 'added': return s.lemmaText ? `Added as "${s.lemmaText}"` : 'Added';
          case 'duplicate_found': return s.lemmaText ? `Already exists as "${s.lemmaText}" — added to list` : 'Added (existing)';
          case 'failed': return s.error ?? 'Failed';
          default: return '';
        }
      };

      const hasResults = statuses.length > 0;
      const allDone = hasResults && !isProcessing;

      return (
        <Modal onClose={onClose} title="Add Vocabulary to List">
          <div className="space-y-4">
            {!hasResults && (
              <>
                <p className="text-sm text-gray-500">
                  Enter Bulgarian word forms, one per line. You can enter inflected forms
                  (e.g. чете) or lemmas (чета) — the app will detect the canonical form.
                </p>
                <textarea
                  value={input}
                  onChange={e => setInput(e.target.value)}
                  placeholder={"чете\nказвам\nказвам се\nобичам"}
                  rows={8}
                  className="w-full border border-gray-300 rounded-xl px-4 py-3 text-lg
                             focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                  style={{ fontFamily: 'Sofia Sans, sans-serif' }}
                  disabled={isProcessing}
                  autoFocus
                />
                <p className="text-xs text-gray-400">
                  {parseWords(input).length} word{parseWords(input).length !== 1 ? 's' : ''} to add
                </p>
              </>
            )}

            {hasResults && (
              <div className="space-y-2 max-h-[50vh] overflow-y-auto">
                {statuses.map((s, i) => (
                  <div key={i} className="flex items-start gap-3 py-2 border-b border-gray-50 last:border-0">
                    <span className={`font-bold mt-0.5 ${statusColor(s.status)}`}>
                      {statusIcon(s.status)}
                    </span>
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-gray-800"
                         style={{ fontFamily: 'Sofia Sans, sans-serif' }}>
                        {s.word}
                      </p>
                      {statusLabel(s) && (
                        <p className={`text-sm ${statusColor(s.status)}`}>{statusLabel(s)}</p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}

            <div className="flex gap-3 pt-2">
              <button
                onClick={onClose}
                className="flex-1 py-3 border border-gray-300 rounded-xl text-gray-700
                           font-medium hover:bg-gray-50 transition-colors min-h-[44px]">
                {allDone ? 'Done' : 'Cancel'}
              </button>
              {!hasResults && (
                <button
                  onClick={processWords}
                  disabled={parseWords(input).length === 0 || isProcessing}
                  className="flex-1 py-3 bg-blue-600 text-white font-semibold rounded-xl
                             hover:bg-blue-700 transition-colors disabled:opacity-50 min-h-[44px]">
                  Add All
                </button>
              )}
              {allDone && (
                <button
                  onClick={() => { setStatuses([]); setInput(''); }}
                  className="flex-1 py-3 bg-blue-600 text-white font-semibold rounded-xl
                             hover:bg-blue-700 transition-colors min-h-[44px]">
                  Add More
                </button>
              )}
            </div>
          </div>
        </Modal>
      );
    }
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/frontend && npx tsc --noEmit 2>&1 | tail -10
  </verify>
  <done>AddVocabularyToList component created. TypeScript passes.</done>
</task>

<task type="auto">
  <name>Task 3: Wire study launch and AddVocabularyToList into App.tsx</name>
  <files>
    frontend/src/App.tsx
  </files>
  <action>
    Read App.tsx. Add the following:

    **Imports to add:**
    ```tsx
    import { useStartListSession } from '@/features/lists/api/useStartListSession';
    import { AddVocabularyToList } from '@/features/lists/components/AddVocabularyToList';
    ```

    **State to add:**
    ```tsx
    const [addVocabListId, setAddVocabListId] = useState<number | null>(null);
    const startListSession = useStartListSession();
    ```

    **handleListStudy implementation** (replaces the stub):
    ```tsx
    const handleListStudy = async (listId: number, mode: 'DUE' | 'ALL') => {
      try {
        const result = await startListSession.mutateAsync({ listId, mode });
        // Reuse the existing study store to start the session
        studyStore.startSession(result.sessionId, result.cardCount, result.firstCard);
        setAppView('study');
      } catch (err: any) {
        const msg = err?.response?.data?.detail ?? err?.message ?? 'Failed to start session';
        alert(msg);  // Simple error — no due/new cards in list
      }
    };
    ```

    Where `studyStore` is: `const studyStore = useStudyStore();` (add to existing store reads in App).

    **handleAddVocabulary implementation** (replaces the stub):
    ```tsx
    const handleAddVocabulary = (listId: number) => {
      setAddVocabListId(listId);
    };
    ```

    **Render AddVocabularyToList when open** (add near the other modals):
    ```tsx
    {addVocabListId !== null && (
      <AddVocabularyToList
        listId={addVocabListId}
        onClose={() => setAddVocabListId(null)}
      />
    )}
    ```

    Pass the real handlers to ListDetail:
    ```tsx
    <ListDetail
      listId={selectedListId}
      onBack={handleListBack}
      onStudy={handleListStudy}
      onAddVocabulary={handleAddVocabulary}
    />
    ```
  </action>
  <verify>
    cd /Users/kevin/bulgarian-vocabulary/frontend && npx tsc --noEmit 2>&1 | tail -10
    npm run build 2>&1 | tail -5

    # Manual UAT:
    # 1. Create list "Elena Lesson Test"
    # 2. Tap Add Vocabulary → enter "чете\nказвам" → Add All
    #    → Both words show "Added as чета" / "Added as казвам"
    # 3. List detail shows 2 members
    # 4. Tap Practice All → switches to Study tab, FlashcardView shows чета and казвам
    # 5. Complete session → summary screen → Done → back to Study idle
    # 6. Return to Lists tab — list still shows 2 members
  </verify>
  <done>Study launch and batch add fully wired. App.tsx compiles. All 6 Phase 7 success criteria met.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Add Vocabulary on list detail opens textarea sheet
4. Entering Bulgarian words and pressing Add All processes each word sequentially
5. Status shown per word: added / already exists / failed
6. 409 duplicates are resolved: found in search and added to list
7. Study Due launches session with only due/new cards from the list → switches to Study tab
8. Practice All launches session with all list members → switches to Study tab
9. FlashcardView, rating, and session summary all work identically to global study
10. After study session, returning to Lists tab shows the list unchanged
11. All 6 Phase 7 success criteria verified:
    ✓ Create named word list
    ✓ Add lemmas to word list (batch entry)
    ✓ Remove lemmas from word list
    ✓ Delete word list
    ✓ View all word lists
    ✓ Study word list as flashcard session (both DUE and ALL modes)
</verification>

<success_criteria>
All 6 Phase 7 success criteria met. Batch vocabulary entry works. Both study modes launch correctly. TypeScript and build clean.
</success_criteria>

<output>
After completion, create `.planning/phases/07-word-lists/07-03-SUMMARY.md`
</output>
