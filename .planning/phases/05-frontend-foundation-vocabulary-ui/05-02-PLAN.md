---
phase: 05-frontend-foundation-vocabulary-ui
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/features/vocabulary/api/useVocabulary.ts
  - frontend/src/features/vocabulary/api/useSearchVocabulary.ts
  - frontend/src/features/vocabulary/stores/useVocabularyUIStore.ts
  - frontend/src/features/vocabulary/components/VocabularyList.tsx
  - frontend/src/features/vocabulary/components/VocabularyCard.tsx
  - frontend/src/features/vocabulary/components/VocabularyFilters.tsx
  - frontend/src/features/vocabulary/components/Pagination.tsx
  - frontend/src/hooks/useDebounce.ts
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can view paginated vocabulary list with Bulgarian Cyrillic text rendered clearly"
    - "User can search vocabulary by typing Bulgarian text with debounced API calls"
    - "User can filter vocabulary by source, part of speech, and difficulty level"
    - "User can play audio for any lemma in the list"
    - "Vocabulary list is mobile-responsive (single column on phone, multi-column on desktop)"
  artifacts:
    - path: "frontend/src/features/vocabulary/api/useVocabulary.ts"
      provides: "TanStack Query hook for paginated vocabulary fetching"
      contains: "useQuery"
    - path: "frontend/src/features/vocabulary/stores/useVocabularyUIStore.ts"
      provides: "Zustand store for vocabulary UI state (filters, search, pagination)"
      contains: "create"
    - path: "frontend/src/features/vocabulary/components/VocabularyList.tsx"
      provides: "Main vocabulary list page component"
      contains: "VocabularyCard"
    - path: "frontend/src/features/vocabulary/components/VocabularyFilters.tsx"
      provides: "Filter and search controls"
      contains: "searchQuery"
  key_links:
    - from: "frontend/src/features/vocabulary/api/useVocabulary.ts"
      to: "/api/vocabulary"
      via: "axios GET request"
      pattern: "api.*vocabulary"
    - from: "frontend/src/features/vocabulary/components/VocabularyList.tsx"
      to: "frontend/src/features/vocabulary/api/useVocabulary.ts"
      via: "useVocabulary hook call"
      pattern: "useVocabulary"
    - from: "frontend/src/features/vocabulary/components/VocabularyFilters.tsx"
      to: "frontend/src/features/vocabulary/stores/useVocabularyUIStore.ts"
      via: "Zustand store selectors"
      pattern: "useVocabularyUIStore"
---

<objective>
Build the vocabulary list page with search, filtering, pagination, and audio playback -- the primary interface for browsing vocabulary entries.

Purpose: Delivers the main vocabulary browsing experience (success criteria 4, 8, 9, 11) with proper state management patterns (criteria 2, 3).
Output: Complete vocabulary list page with TanStack Query data fetching, Zustand UI state, search/filter controls, audio playback buttons, and mobile-responsive layout.
</objective>

<execution_context>
@/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-frontend-foundation-vocabulary-ui/05-RESEARCH.md
@.planning/phases/05-frontend-foundation-vocabulary-ui/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TanStack Query hooks, Zustand store, and shared hooks</name>
  <files>
    frontend/src/features/vocabulary/api/useVocabulary.ts
    frontend/src/features/vocabulary/api/useSearchVocabulary.ts
    frontend/src/features/vocabulary/stores/useVocabularyUIStore.ts
    frontend/src/hooks/useDebounce.ts
  </files>
  <action>
    **1. Create useDebounce hook** (`frontend/src/hooks/useDebounce.ts`):
    - Generic hook: `useDebounce<T>(value: T, delay: number): T`
    - Uses useState + useEffect with setTimeout/clearTimeout
    - Default delay: 300ms
    - Returns debounced value

    **2. Create useVocabulary TanStack Query hook** (`frontend/src/features/vocabulary/api/useVocabulary.ts`):
    - Parameters: `{ page?: number; size?: number; source?: Source | null; partOfSpeech?: PartOfSpeech | null; difficultyLevel?: DifficultyLevel | null }`
    - Query key: `['vocabulary', { page, size, source, partOfSpeech, difficultyLevel }]`
    - Query function: GET `/api/vocabulary` with query params (only include non-null filters)
    - Returns `useQuery<PaginatedResponse<LemmaResponseDTO>>`
    - staleTime: inherit from client (5 min)

    **3. Create useSearchVocabulary hook** (`frontend/src/features/vocabulary/api/useSearchVocabulary.ts`):
    - Parameters: `query: string` (the search text)
    - Query key: `['vocabulary', 'search', query]`
    - Query function: GET `/api/vocabulary/search?q={query}`
    - `enabled: query.length >= 2` (only search with 2+ characters)
    - Returns `useQuery<LemmaResponseDTO[]>`

    **4. Create Zustand UI store** (`frontend/src/features/vocabulary/stores/useVocabularyUIStore.ts`):
    - State:
      - `searchQuery: string` (raw search input, default '')
      - `selectedSource: Source | null` (default null = all)
      - `selectedPartOfSpeech: PartOfSpeech | null` (default null = all)
      - `selectedDifficultyLevel: DifficultyLevel | null` (default null = all)
      - `currentPage: number` (default 0)
      - `pageSize: number` (default 20)
      - `isCreateModalOpen: boolean` (default false)
      - `isEditModalOpen: boolean` (default false)
      - `editingLemmaId: number | null` (default null)
      - `isDeleteConfirmOpen: boolean` (default false)
      - `deletingLemmaId: number | null` (default null)
    - Actions:
      - `setSearchQuery(query: string)` -- also resets currentPage to 0
      - `setFilter(filter: Partial<{selectedSource, selectedPartOfSpeech, selectedDifficultyLevel}>)` -- also resets currentPage to 0
      - `setCurrentPage(page: number)`
      - `resetFilters()` -- clears all filters AND search, resets page to 0
      - `openCreateModal()`, `closeCreateModal()`
      - `openEditModal(id: number)`, `closeEditModal()`
      - `openDeleteConfirm(id: number)`, `closeDeleteConfirm()`
    - ALWAYS use selectors in components: `useVocabularyUIStore(state => state.field)`
  </action>
  <verify>
    cd /Users/kevin/projects/bulgarian-vocabulary/frontend && npx tsc --noEmit 2>&1 | tail -10
    # No type errors
  </verify>
  <done>
    TanStack Query hooks fetch paginated vocabulary and search results from backend API. Zustand store manages all UI state (filters, search, pagination, modal visibility) with proper selectors. useDebounce hook provides debounced search. All TypeScript types pass compilation.
  </done>
</task>

<task type="auto">
  <name>Task 2: VocabularyList page with cards, filters, pagination, and audio playback</name>
  <files>
    frontend/src/features/vocabulary/components/VocabularyList.tsx
    frontend/src/features/vocabulary/components/VocabularyCard.tsx
    frontend/src/features/vocabulary/components/VocabularyFilters.tsx
    frontend/src/features/vocabulary/components/Pagination.tsx
    frontend/src/App.tsx
  </files>
  <action>
    **1. Create VocabularyFilters component** (`frontend/src/features/vocabulary/components/VocabularyFilters.tsx`):
    - Search input field with placeholder "Search Bulgarian text..." and `lang="bg"` attribute
    - Uses Zustand selectors for searchQuery and setSearchQuery
    - Three select dropdowns for Source, Part of Speech, Difficulty Level
    - Each dropdown has "All" option (null value) plus enum values
    - Display-friendly labels for enum values: e.g., "USER_ENTERED" -> "User Entered", "NOUN" -> "Noun"
    - Reset filters button (visible when any filter is active)
    - Mobile-responsive layout: stack on mobile, row on desktop
    - Styling: `flex flex-col md:flex-row gap-3 mb-6`

    **2. Create VocabularyCard component** (`frontend/src/features/vocabulary/components/VocabularyCard.tsx`):
    - Props: `lemma: LemmaResponseDTO`, `onEdit: (id: number) => void`, `onDelete: (id: number) => void`, `onViewDetail: (id: number) => void`
    - Card layout with:
      - Lemma text in large Bulgarian font: `<h3 className="text-2xl font-semibold" lang="bg">{lemma.text}</h3>`
      - English translation below: `<p className="text-gray-600">{lemma.translation}</p>`
      - Audio play button using AudioPlayer component (URL: `/api/audio/generate` not applicable here -- need to handle audio differently since we don't have pre-generated filenames in the DTO)
      - NOTE on audio: Since LemmaResponseDTO doesn't include audio filename, the AudioPlayer for the list view should trigger audio generation on-demand. Create a helper: when play is clicked, POST to /api/audio/generate with the lemma text, get back the filename, then play /api/audio/{filename}. Cache the filename in component state or a small Zustand slice to avoid re-generating.
      - Metadata badges: part of speech (colored pill), difficulty level (colored pill), source badge
      - Action buttons row: "View" (eye icon or text), "Edit" (pencil), "Delete" (trash) -- small text buttons
      - Review status indicator: small colored dot (green=REVIEWED, yellow=PENDING, red=NEEDS_CORRECTION)
    - Mobile-responsive: full-width card with proper padding

    **3. Create Pagination component** (`frontend/src/features/vocabulary/components/Pagination.tsx`):
    - Props: `currentPage: number`, `totalPages: number`, `onPageChange: (page: number) => void`
    - Shows: Previous button, page numbers (with ellipsis for large sets), Next button
    - Current page highlighted
    - Previous disabled on first page, Next disabled on last page
    - Tailwind styling: inline-flex with border-separated buttons

    **4. Create VocabularyList page component** (`frontend/src/features/vocabulary/components/VocabularyList.tsx`):
    - Reads search query from Zustand store, debounces it with useDebounce(300ms)
    - Conditional data fetching:
      - If debounced search has 2+ chars: use `useSearchVocabulary(debouncedQuery)`
      - Else: use `useVocabulary({ page, size, source, partOfSpeech, difficultyLevel })` from Zustand store
    - Page header: "Vocabulary" title + "Add Vocabulary" button (calls openCreateModal from Zustand)
    - VocabularyFilters component
    - Loading state: skeleton cards or spinner
    - Empty state: "No vocabulary entries found" message with suggestion to add first entry
    - Error state: error message with retry button
    - Grid of VocabularyCards: `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4`
    - Pagination component (only shown for browse mode, not search mode)
    - Total count display: "Showing X of Y entries"
    - Card click handlers: onEdit -> openEditModal, onDelete -> openDeleteConfirm, onViewDetail -> (placeholder for now, Plan 04 adds navigation)

    **5. Wire up App.tsx:**
    - Replace placeholder with VocabularyList component
    - Import VocabularyList from features/vocabulary/components/VocabularyList

    **Audio on-demand pattern for VocabularyCard:**
    Create a small custom hook `useAudioPlayback` in `frontend/src/features/vocabulary/api/useAudioPlayback.ts`:
    - Takes `text: string` (Bulgarian text)
    - Manages state: `audioUrl: string | null`, `isLoading: boolean`
    - `play()` function: if audioUrl is cached, play immediately; else POST /api/audio/generate with text, get filename, set audioUrl to `/api/audio/{filename}`, then play
    - Uses a module-level Map<string, string> cache (text -> audioUrl) to avoid re-generating
    - Returns `{ audioUrl, isLoading, play }`
    - The AudioPlayer component from Plan 01 can be used once we have the URL
    - OR: Create a PlayButton wrapper that uses this hook internally

    Actually, simpler approach: Create an `AudioPlayButton` component that:
    - On click: calls POST /api/audio/generate with the lemma text
    - Stores the returned filename in local state
    - Once filename is available, uses a hidden `<audio>` element to play it
    - Shows loading spinner during generation
    - Caches generated filenames in a module-level Map to avoid repeated API calls

    Create this as `frontend/src/components/audio/AudioPlayButton.tsx`.
  </action>
  <verify>
    cd /Users/kevin/projects/bulgarian-vocabulary/frontend && npx tsc --noEmit 2>&1 | tail -10
    # No type errors

    cd /Users/kevin/projects/bulgarian-vocabulary/frontend && npm run build 2>&1 | tail -5
    # Build succeeds
  </verify>
  <done>
    Vocabulary list page renders with responsive card grid (1 col mobile, 2 cols tablet, 3 cols desktop). Search input debounces and calls backend PGroonga search. Filter dropdowns for source, part of speech, difficulty level update the query. Pagination controls navigate pages. Each card shows lemma text in large Bulgarian font, translation, metadata badges, audio play button, and action buttons (view, edit, delete). Audio plays on demand via POST /api/audio/generate then GET /api/audio/{filename}. All data fetched via TanStack Query hooks, UI state via Zustand selectors.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in frontend/
2. `npx tsc --noEmit` passes in frontend/
3. VocabularyList renders vocabulary cards from backend API
4. Search input debounces and triggers PGroonga search after 2+ characters
5. Filter dropdowns update query parameters and refetch data
6. Pagination navigates through pages
7. Audio play buttons trigger generation and playback
8. Layout is responsive: 1 column on mobile, 2-3 on desktop
9. Bulgarian Cyrillic text uses Sofia Sans font with lang="bg"
</verification>

<success_criteria>
- User sees paginated vocabulary list with Bulgarian text in large clear font
- User can search by typing Bulgarian text (debounced, 2+ char minimum)
- User can filter by source, part of speech, difficulty level
- User can play audio for any lemma in the list
- List is mobile-responsive with card grid layout
- TanStack Query manages all server data fetching
- Zustand manages filter/search/pagination UI state with selectors
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-foundation-vocabulary-ui/05-02-SUMMARY.md`
</output>
