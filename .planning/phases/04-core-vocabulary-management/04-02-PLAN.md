---
phase: 04-core-vocabulary-management
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/main/java/com/vocab/bulgarian/api/mapper/LemmaMapper.java
  - backend/src/main/java/com/vocab/bulgarian/service/VocabularyService.java
  - backend/src/main/java/com/vocab/bulgarian/api/controller/VocabularyController.java
autonomous: true

must_haves:
  truths:
    - "User can enter any Bulgarian word form and system detects canonical lemma via LLM"
    - "User can enter multi-word lemma explicitly"
    - "User can enter English translation (required) and notes (optional)"
    - "LLM auto-generates inflections, part of speech, category, difficulty level"
    - "User can review LLM-generated metadata before saving (create returns full detail for review)"
    - "User can edit vocabulary entry (lemma text, translation, notes, inflections)"
    - "User can delete vocabulary entry"
    - "User can browse all vocabulary entries with pagination"
    - "User can search vocabulary by lemma text (PGroonga Cyrillic full-text search)"
    - "User can filter vocabulary by part of speech, category, difficulty, source"
    - "System distinguishes user-entered from system-seeded vocabulary"
    - "System-seeded reference vocabulary (52 entries) is already present via Flyway"
  artifacts:
    - path: "backend/src/main/java/com/vocab/bulgarian/api/mapper/LemmaMapper.java"
      provides: "MapStruct mapper for entity-DTO conversion"
      contains: "@Mapper(componentModel"
    - path: "backend/src/main/java/com/vocab/bulgarian/service/VocabularyService.java"
      provides: "Business logic with LLM orchestration integration"
      contains: "LlmOrchestrationService"
    - path: "backend/src/main/java/com/vocab/bulgarian/api/controller/VocabularyController.java"
      provides: "REST endpoints for vocabulary CRUD"
      contains: "@RestController"
  key_links:
    - from: "api/controller/VocabularyController.java"
      to: "service/VocabularyService.java"
      via: "constructor injection"
      pattern: "VocabularyService"
    - from: "service/VocabularyService.java"
      to: "llm/service/LlmOrchestrationService.java"
      via: "processNewWord() call"
      pattern: "llmOrchestrationService\\.processNewWord"
    - from: "service/VocabularyService.java"
      to: "repository/LemmaRepository.java"
      via: "JPA persistence"
      pattern: "lemmaRepository\\.(save|findById|delete)"
    - from: "api/mapper/LemmaMapper.java"
      to: "domain/Lemma.java"
      via: "entity-DTO mapping"
      pattern: "toResponseDTO|toDetailDTO"
    - from: "api/controller/VocabularyController.java"
      to: "api/dto/"
      via: "request/response types"
      pattern: "CreateLemmaRequestDTO|LemmaResponseDTO|LemmaDetailDTO"
---

<objective>
Implement the VocabularyService with LLM orchestration integration, MapStruct mapper, and VocabularyController with complete REST CRUD endpoints for vocabulary management.

Purpose: This is the core plan that wires together the existing LLM orchestration (Phase 2), audio generation (Phase 3), entity model (Phase 1), and the DTOs/infrastructure from Plan 01 into a working vocabulary management API. It delivers all 13 success criteria for Phase 4.

Output: Working REST API at /api/vocabulary with POST (create with LLM), GET (browse/search/filter/detail), PUT (update), DELETE endpoints. MapStruct mapper handles all entity-DTO conversions.
</objective>

<execution_context>
@/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-vocabulary-management/04-RESEARCH.md
@.planning/phases/04-core-vocabulary-management/04-01-SUMMARY.md
@backend/pom.xml
@backend/src/main/java/com/vocab/bulgarian/domain/Lemma.java
@backend/src/main/java/com/vocab/bulgarian/domain/Inflection.java
@backend/src/main/java/com/vocab/bulgarian/domain/enums/Source.java
@backend/src/main/java/com/vocab/bulgarian/domain/enums/PartOfSpeech.java
@backend/src/main/java/com/vocab/bulgarian/domain/enums/DifficultyLevel.java
@backend/src/main/java/com/vocab/bulgarian/domain/enums/ReviewStatus.java
@backend/src/main/java/com/vocab/bulgarian/repository/LemmaRepository.java
@backend/src/main/java/com/vocab/bulgarian/llm/service/LlmOrchestrationService.java
@backend/src/main/java/com/vocab/bulgarian/llm/dto/LlmProcessingResult.java
@backend/src/main/java/com/vocab/bulgarian/llm/dto/LemmaDetectionResponse.java
@backend/src/main/java/com/vocab/bulgarian/llm/dto/InflectionSet.java
@backend/src/main/java/com/vocab/bulgarian/llm/dto/LemmaMetadata.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/CreateLemmaRequestDTO.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/UpdateLemmaRequestDTO.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/LemmaResponseDTO.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/LemmaDetailDTO.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/InflectionDTO.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/InflectionUpdateDTO.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/OnCreate.java
@backend/src/main/java/com/vocab/bulgarian/api/dto/OnUpdate.java
@backend/src/main/java/com/vocab/bulgarian/api/exception/GlobalExceptionHandler.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LemmaMapper and VocabularyService with LLM orchestration</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/api/mapper/LemmaMapper.java
    backend/src/main/java/com/vocab/bulgarian/service/VocabularyService.java
  </files>
  <action>
    1. Create `LemmaMapper.java` in `com.vocab.bulgarian.api.mapper`:
       - Annotate with `@Mapper(componentModel = "spring")`
       - **Entity to LemmaResponseDTO mapping:**
         - `LemmaResponseDTO toResponseDTO(Lemma lemma)`
         - Map `inflectionCount` using `@Mapping(target = "inflectionCount", expression = "java(lemma.getInflections() != null ? lemma.getInflections().size() : 0)")`
         - All other fields map by name (id, text, translation, partOfSpeech, category, difficultyLevel, source, reviewStatus, createdAt)
       - **Entity to LemmaDetailDTO mapping:**
         - `LemmaDetailDTO toDetailDTO(Lemma lemma)`
         - Map `inflections` from entity's inflection list using `toInflectionDTO` method
         - All other fields by name
       - **Inflection to InflectionDTO:**
         - `InflectionDTO toInflectionDTO(Inflection inflection)` -- maps id, form, grammaticalInfo by name
       - **LlmProcessingResult + CreateLemmaRequestDTO to Lemma entity:**
         - `default Lemma toEntity(CreateLemmaRequestDTO request, LlmProcessingResult llmResult)` -- implement as default method (complex mapping logic that MapStruct can't auto-generate cleanly):
           - Create new Lemma instance
           - Set text: if `llmResult.lemmaDetection() != null && !llmResult.lemmaDetection().detectionFailed()` use `llmResult.lemmaDetection().lemma()`, otherwise use `request.wordForm()` (fallback to user input)
           - Set translation from request.translation()
           - Set notes from request.notes()
           - Set source to Source.USER_ENTERED
           - If `llmResult.metadata() != null`: set partOfSpeech by parsing enum `PartOfSpeech.valueOf(llmResult.metadata().partOfSpeech().toUpperCase())` with try-catch (null on parse failure), set category from metadata.category(), set difficultyLevel by parsing enum `DifficultyLevel.valueOf(llmResult.metadata().difficultyLevel().toUpperCase())` with try-catch
           - If `llmResult.fullySuccessful()`: set reviewStatus to PENDING, else set to NEEDS_CORRECTION
           - If `llmResult.inflections() != null`: iterate inflections, create Inflection entities, use `lemma.addInflection()` helper to maintain bidirectional relationship. For each InflectionSet.InflectionEntry: set form to entry.text(), set grammaticalInfo to entry.grammaticalTags()
           - Return lemma
       - **UpdateLemmaRequestDTO to existing entity (for updates):**
         - `default void updateEntity(UpdateLemmaRequestDTO request, Lemma lemma)` -- default method:
           - Set lemma.setText(request.text())
           - Set lemma.setTranslation(request.translation())
           - Set lemma.setNotes(request.notes())
           - If request.inflections() is not null: clear existing inflections via `lemma.getInflections().clear()` (orphanRemoval handles delete), then add new ones using `lemma.addInflection()` for each InflectionUpdateDTO

    2. Create `VocabularyService.java` in `com.vocab.bulgarian.service`:
       - Annotate with `@Service` and `@Transactional(readOnly = true)` at class level
       - Constructor-inject: `LemmaRepository`, `LlmOrchestrationService`, `LemmaMapper`
       - **createVocabulary(CreateLemmaRequestDTO request) -> CompletableFuture<LemmaDetailDTO>:**
         - Annotate with `@Transactional` (overrides class-level readOnly)
         - Call `llmOrchestrationService.processNewWord(request.wordForm())` which returns CompletableFuture<LlmProcessingResult>
         - Use `.thenApply()`:
           - Call `lemmaMapper.toEntity(request, llmResult)` to create entity
           - Save via `lemmaRepository.save(lemma)`
           - Return `lemmaMapper.toDetailDTO(saved)` -- returns detail view so user can review LLM-generated metadata
       - **getVocabularyById(Long id) -> LemmaDetailDTO:**
         - Use `lemmaRepository.findByIdWithInflections(id)` to avoid N+1
         - Throw `jakarta.persistence.EntityNotFoundException("Lemma not found with id: " + id)` if not found
         - Return `lemmaMapper.toDetailDTO(lemma)`
       - **browseVocabulary(Source source, PartOfSpeech partOfSpeech, DifficultyLevel difficultyLevel, Pageable pageable) -> Page<LemmaResponseDTO>:**
         - Build query based on which filter params are non-null:
           - All three non-null: `findBySourceAndPartOfSpeechAndDifficultyLevel`
           - source + partOfSpeech: `findBySourceAndPartOfSpeech`
           - source + difficultyLevel: `findBySourceAndDifficultyLevel`
           - partOfSpeech + difficultyLevel: `findByPartOfSpeechAndDifficultyLevel`
           - source only: `findBySource`
           - partOfSpeech only: `findByPartOfSpeech`
           - difficultyLevel only: `findByDifficultyLevel`
           - none: `findAll(pageable)`
         - Map result using `.map(lemmaMapper::toResponseDTO)`
         - NOTE: inflectionCount in response will be 0 for paginated queries since inflections are lazy-loaded. This is acceptable for the list view -- detail view (getById) loads inflections via JOIN FETCH.
       - **searchVocabulary(String query) -> List<LemmaResponseDTO>:**
         - Call `lemmaRepository.searchByText(query)` (PGroonga native query)
         - Map to response DTOs. Since searchByText returns native query results, inflections won't be loaded (lazy), so inflectionCount will show 0 in list view. This is acceptable.
       - **updateVocabulary(Long id, UpdateLemmaRequestDTO request) -> LemmaDetailDTO:**
         - Annotate with `@Transactional`
         - Fetch existing lemma via `findByIdWithInflections(id)`, throw EntityNotFoundException if not found
         - Call `lemmaMapper.updateEntity(request, lemma)`
         - Set reviewStatus to PENDING (re-review after edit)
         - Save and return detail DTO
       - **deleteVocabulary(Long id) -> void:**
         - Annotate with `@Transactional`
         - Check `lemmaRepository.existsById(id)`, throw EntityNotFoundException if not found
         - Call `lemmaRepository.deleteById(id)` -- cascade deletes inflections (ON DELETE CASCADE in schema)
       - **updateReviewStatus(Long id, ReviewStatus status) -> LemmaDetailDTO:**
         - Annotate with `@Transactional`
         - Fetch lemma by id (without inflections, simple findById is fine)
         - Set reviewStatus
         - Save and return detail DTO (reload with inflections for response)
  </action>
  <verify>
    Run `cd /Users/kevin/projects/bulgarian-vocabulary/backend && mvn compile -q` -- must compile with no errors. Verify LemmaMapper.java and VocabularyService.java exist at expected paths. Verify VocabularyService has @Transactional annotations on write methods.
  </verify>
  <done>
    LemmaMapper handles all DTO-entity conversions including complex LlmProcessingResult mapping with enum parsing and bidirectional relationship maintenance. VocabularyService integrates LlmOrchestrationService.processNewWord() for create flow, supports paginated browse with multi-field filtering, PGroonga search, CRUD operations with proper transactional boundaries, and review status updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VocabularyController with complete REST endpoints</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/api/controller/VocabularyController.java
  </files>
  <action>
    Create `VocabularyController.java` in `com.vocab.bulgarian.api.controller`:
    - Annotate with `@RestController` and `@RequestMapping("/api/vocabulary")`
    - Constructor-inject: `VocabularyService`

    Endpoints:

    1. **POST /api/vocabulary** -- Create new vocabulary entry with LLM processing
       - Accepts `@Validated(OnCreate.class) @RequestBody CreateLemmaRequestDTO request`
       - Returns `CompletableFuture<ResponseEntity<LemmaDetailDTO>>`
       - Call `vocabularyService.createVocabulary(request)`
       - Use `.thenApply(dto -> ResponseEntity.status(HttpStatus.CREATED).body(dto))`
       - Returns 201 Created with full detail (including LLM-generated metadata for user review)

    2. **GET /api/vocabulary/{id}** -- Get vocabulary entry detail
       - Accepts `@PathVariable Long id`
       - Returns `ResponseEntity<LemmaDetailDTO>`
       - Returns 200 OK with detail including inflections list

    3. **GET /api/vocabulary** -- Browse/filter vocabulary with pagination
       - Accepts optional query params:
         - `@RequestParam(required = false) Source source`
         - `@RequestParam(required = false) PartOfSpeech partOfSpeech`
         - `@RequestParam(required = false) DifficultyLevel difficultyLevel`
         - `@RequestParam(defaultValue = "0") int page`
         - `@RequestParam(defaultValue = "20") int size`
         - `@RequestParam(defaultValue = "text") String sort`
       - Create `PageRequest.of(page, size, Sort.by(sort))` pageable
       - Returns `ResponseEntity<Page<LemmaResponseDTO>>`
       - Returns 200 OK with paginated results

    4. **GET /api/vocabulary/search** -- Full-text search (PGroonga Cyrillic)
       - Accepts `@RequestParam String q`
       - Returns `ResponseEntity<List<LemmaResponseDTO>>`
       - Returns 200 OK with search results (up to 20, per PGroonga LIMIT)

    5. **PUT /api/vocabulary/{id}** -- Update vocabulary entry
       - Accepts `@PathVariable Long id` and `@Validated(OnUpdate.class) @RequestBody UpdateLemmaRequestDTO request`
       - Returns `ResponseEntity<LemmaDetailDTO>`
       - Returns 200 OK with updated detail

    6. **DELETE /api/vocabulary/{id}** -- Delete vocabulary entry
       - Accepts `@PathVariable Long id`
       - Returns `ResponseEntity<Void>`
       - Returns 204 No Content

    7. **PATCH /api/vocabulary/{id}/review-status** -- Update review status
       - Accepts `@PathVariable Long id` and `@RequestParam ReviewStatus status`
       - Returns `ResponseEntity<LemmaDetailDTO>`
       - Returns 200 OK with updated detail

    Import `org.springframework.data.domain.PageRequest`, `org.springframework.data.domain.Sort`, `org.springframework.validation.annotation.Validated`.
  </action>
  <verify>
    Run `cd /Users/kevin/projects/bulgarian-vocabulary/backend && mvn compile -q` -- must compile with no errors. Verify VocabularyController.java exists and contains @RestController annotation. Verify all 7 endpoint methods exist. Grep for "@PostMapping", "@GetMapping", "@PutMapping", "@DeleteMapping", "@PatchMapping" to confirm all HTTP methods.
  </verify>
  <done>
    VocabularyController exposes 7 REST endpoints covering all Phase 4 success criteria:
    - POST /api/vocabulary: Create with LLM orchestration (VOCAB-01 through VOCAB-06)
    - GET /api/vocabulary/{id}: Detail view with inflections (VOCAB-09)
    - GET /api/vocabulary: Paginated browse with filtering (VOCAB-09, VOCAB-11)
    - GET /api/vocabulary/search: PGroonga Cyrillic full-text search (VOCAB-10)
    - PUT /api/vocabulary/{id}: Edit lemma, translation, notes, inflections (VOCAB-07)
    - DELETE /api/vocabulary/{id}: Delete with cascade (VOCAB-08)
    - PATCH /api/vocabulary/{id}/review-status: Review workflow (REF-05, VOCAB-06)
    All endpoints use proper HTTP status codes (201, 200, 204) and validation groups.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/kevin/projects/bulgarian-vocabulary/backend && mvn compile -q` passes with zero errors
2. MapStruct generates LemmaMapperImpl at compile time (check target/generated-sources)
3. VocabularyService is @Transactional(readOnly=true) at class level with @Transactional on write methods
4. VocabularyController has 7 endpoint methods covering all CRUD + search + filter + review
5. Create endpoint returns CompletableFuture (async LLM processing)
6. Browse endpoint accepts Source, PartOfSpeech, DifficultyLevel filter params with Pageable
7. Search endpoint uses PGroonga via repository.searchByText()
8. Delete uses cascade (deleteById triggers ON DELETE CASCADE on inflections)
</verification>

<success_criteria>
Phase 4 complete when:
- POST /api/vocabulary creates entry with LLM-detected lemma, inflections, metadata, and ReviewStatus.PENDING/NEEDS_CORRECTION
- GET /api/vocabulary returns paginated, filterable list of vocabulary entries
- GET /api/vocabulary/search returns PGroonga Cyrillic search results
- GET /api/vocabulary/{id} returns detail with inflections
- PUT /api/vocabulary/{id} updates lemma text, translation, notes, and optionally inflections
- DELETE /api/vocabulary/{id} removes entry and cascaded inflections
- PATCH /api/vocabulary/{id}/review-status updates review workflow status
- Validation errors return 400 with ProblemDetail, not-found returns 404
- System-seeded reference vocabulary (52 entries) browsable with source=SYSTEM_SEED filter
- Project compiles cleanly with `mvn compile`
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-vocabulary-management/04-02-SUMMARY.md`
</output>
