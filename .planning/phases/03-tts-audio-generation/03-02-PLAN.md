---
phase: 03-tts-audio-generation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/src/main/java/com/vocab/bulgarian/audio/service/EdgeTtsService.java
  - backend/src/main/java/com/vocab/bulgarian/audio/service/AudioGenerationService.java
  - backend/src/main/java/com/vocab/bulgarian/audio/controller/AudioController.java
autonomous: true

must_haves:
  truths:
    - "System can generate an MP3 audio file for Bulgarian text using edge-tts CLI"
    - "Audio files are stored on disk at the configured storage path"
    - "Identical text with the same voice produces the same filename and skips regeneration"
    - "Audio generation runs asynchronously without blocking the calling thread"
    - "GET /api/audio/{filename} returns an audio/mpeg response for valid files"
    - "Invalid or path-traversal filenames are rejected with 400"
    - "Non-existent audio files return 404"
  artifacts:
    - path: "backend/src/main/java/com/vocab/bulgarian/audio/service/EdgeTtsService.java"
      provides: "Edge TTS CLI execution via ProcessBuilder with file caching"
      contains: "ProcessBuilder"
      exports: ["generateAudio"]
    - path: "backend/src/main/java/com/vocab/bulgarian/audio/service/AudioGenerationService.java"
      provides: "Async wrapper for TTS generation"
      contains: "@Async"
      exports: ["generateAudioAsync"]
    - path: "backend/src/main/java/com/vocab/bulgarian/audio/controller/AudioController.java"
      provides: "REST endpoint for serving audio files"
      contains: "@GetMapping"
      exports: ["GET /api/audio/{filename}"]
  key_links:
    - from: "backend/src/main/java/com/vocab/bulgarian/audio/service/AudioGenerationService.java"
      to: "backend/src/main/java/com/vocab/bulgarian/audio/service/EdgeTtsService.java"
      via: "dependency injection"
      pattern: "edgeTtsService\\.generateAudio"
    - from: "backend/src/main/java/com/vocab/bulgarian/audio/service/EdgeTtsService.java"
      to: "edge-tts CLI"
      via: "ProcessBuilder"
      pattern: "ProcessBuilder.*edge-tts"
    - from: "backend/src/main/java/com/vocab/bulgarian/audio/service/EdgeTtsService.java"
      to: "backend/src/main/java/com/vocab/bulgarian/audio/util/ContentHashUtil.java"
      via: "static method call"
      pattern: "ContentHashUtil\\.generateHash"
    - from: "backend/src/main/java/com/vocab/bulgarian/audio/controller/AudioController.java"
      to: "audio storage directory"
      via: "@Value injection of audio.storage.path"
      pattern: "audio\\.storage\\.path"
---

<objective>
TTS service layer (edge-tts CLI execution, async wrapper) and REST endpoint for serving generated audio files.

Purpose: This is the core TTS functionality -- generating audio for Bulgarian text and serving it via HTTP. It completes all five success criteria for Phase 3.
Output: Three Java classes implementing audio generation, caching, and serving.
</objective>

<execution_context>
@/Users/kevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-tts-audio-generation/03-RESEARCH.md
@.planning/phases/03-tts-audio-generation/03-01-SUMMARY.md
@backend/src/main/java/com/vocab/bulgarian/llm/service/LemmaDetectionService.java
@backend/src/main/java/com/vocab/bulgarian/audio/util/ContentHashUtil.java
@backend/src/main/java/com/vocab/bulgarian/audio/config/AudioStorageConfig.java
@backend/src/main/java/com/vocab/bulgarian/audio/config/AudioAsyncConfig.java
@backend/src/main/java/com/vocab/bulgarian/audio/exception/AudioGenerationException.java
@backend/src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EdgeTtsService with ProcessBuilder CLI execution and file caching</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/audio/service/EdgeTtsService.java
  </files>
  <action>
Create `EdgeTtsService.java` in `com.vocab.bulgarian.audio.service` package.

This is the synchronous core service (following Phase 2's two-layer async pattern where the sync method handles caching and the async wrapper handles threading).

**Class structure:**
- @Service annotation
- SLF4J Logger
- Constructor injection:
  - @Value("${audio.storage.path}") String audioStoragePath
  - @Value("${tts.bulgarian.voice.default}") String defaultVoice

**Method: `generateAudio(String bulgarianText, String voiceName)`**
- Returns String (the filename, e.g., "a3f5b8c2...64chars.mp3")
- @Cacheable(value = "audioFiles", key = "T(com.vocab.bulgarian.audio.util.ContentHashUtil).generateHash(#bulgarianText, #voiceName)")
  - Cache key is the hash itself, not the Cyrillic text (avoids encoding issues per research pitfall #8)
- Implementation:
  1. Generate hash: `String hash = ContentHashUtil.generateHash(bulgarianText, voiceName)`
  2. Build filename: `hash + ".mp3"`
  3. Resolve path: `Path filePath = Paths.get(audioStoragePath, filename)`
  4. **Idempotency check:** If `Files.exists(filePath)`, log and return filename immediately
  5. **Atomic generation with temp file:**
     - Create temp file in same directory: `Path tempFile = Files.createTempFile(Paths.get(audioStoragePath), "audio-", ".tmp")`
     - Build ProcessBuilder with SEPARATE arguments (pitfall #1): `new ProcessBuilder("edge-tts", "--voice", voiceName, "--text", bulgarianText, "--write-media", tempFile.toString())`
     - Redirect stderr into stdout: `pb.redirectErrorStream(true)`
     - Start process
     - **Consume process output** in current thread to prevent buffer blocking (pitfall #4):
       ```java
       try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
           String line;
           while ((line = reader.readLine()) != null) {
               log.debug("edge-tts: {}", line);
           }
       }
       ```
     - Wait for process with timeout: `boolean completed = process.waitFor(30, TimeUnit.SECONDS)`
     - If not completed: `process.destroyForcibly()`, delete temp file, throw AudioGenerationException
     - If exit code != 0: delete temp file, throw AudioGenerationException with exit code
     - Atomic move: `Files.move(tempFile, filePath, StandardCopyOption.REPLACE_EXISTING)`
  6. Log success and return filename
  7. In catch block: `Files.deleteIfExists(tempFile)` before rethrowing

**Method: `generateAudio(String bulgarianText)`** (overload)
- Calls `generateAudio(bulgarianText, defaultVoice)` using the injected default voice

**Method: `isEdgeTtsAvailable()`**
- Returns boolean
- Runs `new ProcessBuilder("edge-tts", "--version")` with 5-second timeout
- Returns true if exit code 0, false otherwise
- Used by health checks / startup validation
- Logs warning if not available

Follow the LemmaDetectionService pattern for structure/style but adapted for ProcessBuilder instead of ChatClient. Do NOT add @CircuitBreaker here -- edge-tts is local CLI, not a remote service.
  </action>
  <verify>
Run `cd /Users/kevin/projects/bulgarian-vocabulary/backend && mvn compile -pl . -q` -- must compile without errors. Verify file exists with @Cacheable annotation and ProcessBuilder usage.
  </verify>
  <done>
EdgeTtsService.generateAudio("Здравей", "bg-BG-KalinaNeural") calls edge-tts CLI via ProcessBuilder, saves MP3 to configured storage path with content-hash filename, returns filename string. File existence check prevents regeneration. Temp file + atomic move prevents partial files. Process output consumed to prevent hanging. 30-second timeout prevents indefinite blocking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AudioGenerationService async wrapper and AudioController REST endpoint</name>
  <files>
    backend/src/main/java/com/vocab/bulgarian/audio/service/AudioGenerationService.java
    backend/src/main/java/com/vocab/bulgarian/audio/controller/AudioController.java
  </files>
  <action>
**AudioGenerationService.java** in `com.vocab.bulgarian.audio.service`:

Async wrapper following Phase 2's two-layer pattern (see LemmaDetectionService for reference).

- @Service annotation
- SLF4J Logger
- Constructor injection of EdgeTtsService

**Method: `generateAudioAsync(String bulgarianText, String voiceName)`**
- @Async("audioTaskExecutor") -- uses the audio-specific thread pool, NOT the LLM one
- Returns CompletableFuture&lt;String&gt;
- Calls `edgeTtsService.generateAudio(bulgarianText, voiceName)` synchronously
- Wraps result in `CompletableFuture.completedFuture(result)`
- Log entry/exit at debug level

**Method: `generateAudioAsync(String bulgarianText)`** (overload)
- @Async("audioTaskExecutor")
- Returns CompletableFuture&lt;String&gt;
- Calls the single-arg `edgeTtsService.generateAudio(bulgarianText)` (uses default voice)
- Wraps in CompletableFuture.completedFuture()

**AudioController.java** in `com.vocab.bulgarian.audio.controller`:

REST endpoint for serving audio files with security validation.

- @RestController, @RequestMapping("/api/audio")
- SLF4J Logger
- Constructor injection: @Value("${audio.storage.path}") String audioStoragePath

**Method: `getAudioFile(@PathVariable String filename)`**
- @GetMapping("/{filename}")
- Returns ResponseEntity&lt;Resource&gt;
- Implementation with three defense layers:

  **Defense 1 - Whitelist validation:**
  - `if (!filename.matches("^[a-f0-9]{64}\\.mp3$"))` return 400 Bad Request
  - Log warning with the rejected filename

  **Defense 2 - Path normalization and containment:**
  - `Path storagePath = Paths.get(audioStoragePath).toAbsolutePath().normalize()`
  - `Path requestedPath = storagePath.resolve(filename).normalize()`
  - `if (!requestedPath.startsWith(storagePath))` return 403 Forbidden
  - Log error for path traversal attempt

  **Defense 3 - Existence check:**
  - `if (!Files.exists(requestedPath) || !Files.isRegularFile(requestedPath))` return 404

  **Success response:**
  - Content-Type: `audio/mpeg`
  - Content-Disposition: `inline; filename="{filename}"` (inline for browser playback)
  - Cache-Control: `public, max-age=31536000, immutable` (content-hash filenames are immutable -- same hash always = same content)
  - Body: `new FileSystemResource(requestedPath)`

**Method: `checkHealth()`**
- @GetMapping("/health")
- Returns ResponseEntity&lt;Map&lt;String, Object&gt;&gt;
- Calls `edgeTtsService.isEdgeTtsAvailable()` (inject EdgeTtsService)
- Returns JSON: `{"available": true/false, "storagePath": "...", "storageExists": true/false}`
- This is a simple health check, not a Spring Actuator endpoint

Both classes follow existing project conventions (constructor injection, SLF4J logging, Jakarta annotations).
  </action>
  <verify>
Run `cd /Users/kevin/projects/bulgarian-vocabulary/backend && mvn compile -pl . -q` -- must compile without errors. Verify both files exist. Verify AudioGenerationService has @Async("audioTaskExecutor") annotation. Verify AudioController has @GetMapping("/{filename}") and filename regex validation.
  </verify>
  <done>
AudioGenerationService.generateAudioAsync() runs TTS generation on dedicated audio thread pool. AudioController serves audio files at GET /api/audio/{filename} with three-layer path traversal prevention (whitelist regex, path normalization, existence check). Health check endpoint at GET /api/audio/health reports edge-tts availability. Cache-Control headers enable browser caching of immutable content-hash files.
  </done>
</task>

</tasks>

<verification>
1. `mvn compile -q` passes with no errors
2. All 3 files exist at specified paths
3. EdgeTtsService uses ProcessBuilder with separate argument strings
4. EdgeTtsService has @Cacheable with hash-based cache key
5. AudioGenerationService has @Async("audioTaskExecutor")
6. AudioController validates filename with regex `^[a-f0-9]{64}\.mp3$`
7. AudioController normalizes paths and checks containment within storage directory
8. AudioController returns proper Content-Type (audio/mpeg) and Cache-Control headers
9. Health check endpoint exists at /api/audio/health
</verification>

<success_criteria>
All five Phase 3 success criteria are met:
1. EdgeTtsService generates audio via edge-tts CLI (Success Criterion 1)
2. Files stored on disk at audio.storage.path (Success Criterion 2)
3. Content-hash filenames + @Cacheable prevent regeneration (Success Criterion 3)
4. @Async("audioTaskExecutor") provides non-blocking generation (Success Criterion 4)
5. GET /api/audio/{filename} serves audio files (Success Criterion 5)
</success_criteria>

<output>
After completion, create `.planning/phases/03-tts-audio-generation/03-02-SUMMARY.md`
</output>
